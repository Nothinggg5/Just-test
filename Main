весь плагин напиши, исправленный 

вот документации infinite yield про плагины:
https://github.com/EdgeIY/infiniteyield/wiki/Creating-A-Plugin
https://github.com/EdgeIY/infiniteyield/wiki/Adding-Commands-To-A-Plugin
https://github.com/EdgeIY/infiniteyield/wiki/Infinite-Yield's-Core-Functions
https://github.com/EdgeIY/infiniteyield/wiki/Loading-Plugin

local Plugin = {
    PluginName = "AdaptiveLidarNavigatorWithColors",
    PluginDescription = "LIDAR навигатор с цветными raycast лучами и интеллектуальным обходом",
    Commands = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local parkourMode = false
local followMode = nil
local currentTarget = nil
local connections = {}

local scanRadiusBase = 120
local safeDistance = 4
local maxJumpHeight = 7
local updateInterval = 0.012
local rayCountBase = 700
local rayCountParkour = 1000

local dangerTags = {"damage", "lava", "fire", "kill", "trap", "spike", "acid", "death"}

local function getCharacter(player)
    if not player or not player.Character then return nil,nil,nil end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return player.Character, hrp, humanoid
end

local function isDangerPart(part)
    if not part or not part:IsA("BasePart") then return false end
    local name = part.Name:lower()
    for _, t in pairs(dangerTags) do
        if name:find(t) then return true end
    end
    if part:GetAttribute("Danger") == true then return true end
    return false
end

local function checkDangerNearby(pos, radius)
    local region = Region3.new(pos - Vector3.new(radius,radius,radius), pos + Vector3.new(radius,radius,radius))
    local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {localPlayer.Character}, 50)
    for _, p in pairs(parts) do
        if isDangerPart(p) then return true end
    end
    return false
end

local function isPathDangerous(startPos, endPos, excludeModel)
    local dir = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {excludeModel}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), dir * distance, rayParams)
    return ray and isDangerPart(ray.Instance)
end

-- Равномерное распределение лучей по сфере с сеткой theta/phi
local function generateUniformSphereRays(rayCount)
    local dirs = {}
    local steps = math.ceil(math.sqrt(rayCount / 2))
    local horizontalSteps = math.ceil(rayCount / steps)
    for i = 0, steps do
        local theta = math.pi * i / steps
        local y = math.cos(theta)
        local r = math.sin(theta)
        for j = 0, horizontalSteps - 1 do
            local phi = 2 * math.pi * j / horizontalSteps
            local x = r * math.cos(phi)
            local z = r * math.sin(phi)
            table.insert(dirs, Vector3.new(x, y, z))
        end
    end
    return dirs
end

local scanDirs = generateUniformSphereRays(rayCountBase)
local scanRadiusCurrent = scanRadiusBase
local updateIntervalCurrent = updateInterval

local lastPositions = {}
local stepSize = 8

local function drawColoredScanVisualization(hrp, chosenDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {hrp.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    for _, dir in ipairs(scanDirs) do
        local ray = Workspace:Raycast(origin, dir * scanRadiusCurrent, rayParams)
        local endPos = ray and ray.Position or (origin + dir * scanRadiusCurrent)

        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.06, 0.06, (endPos - origin).Magnitude)
        part.CFrame = CFrame.new((origin + endPos) / 2, endPos)
        part.Material = Enum.Material.Neon

        if (dir - chosenDir).Magnitude < 0.02 then
            part.Color = Color3.fromRGB(0, 0, 255) -- синий
        elseif not checkDangerNearby(endPos, safeDistance) then
            part.Color = Color3.fromRGB(0, 255, 0) -- зеленый
        else
            part.Color = Color3.fromRGB(255, 0, 0) -- красный
        end

        part.Parent = Workspace
        Debris:AddItem(part, 1.5)
    end
end

local function tryJump(hrp, humanoid, nextPoint)
    if not humanoid or not nextPoint then return false end
    local dy = nextPoint.Y - hrp.Position.Y
    if humanoid.FloorMaterial == Enum.Material.Air then return false end
    if dy > 1.3 and dy < maxJumpHeight then
        local origin = hrp.Position + Vector3.new(0, 2, 0)
        local forward = (nextPoint - hrp.Position).Unit
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local wallCheck = Workspace:Raycast(origin + Vector3.new(0, 0.5, 0), forward * stepSize, rayParams)
        local ceilingCheck = Workspace:Raycast(origin + Vector3.new(0, 2, 0), forward * stepSize, rayParams)
        if wallCheck and not isDangerPart(wallCheck.Instance) and not ceilingCheck then
            humanoid.Jump = true
            task.wait(0.25)
            return true
        end
    end
    return false
end

local function avoidWallCollision(hrp, proposedPos)
    local character = hrp.Parent
    if not character then return proposedPos end
    local dirToProposed = (proposedPos - hrp.Position).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), dirToProposed * stepSize, rayParams)
    if ray and ray.Instance and not isDangerPart(ray.Instance) then
        for _, dir in ipairs(scanDirs) do
            if dirToProposed:Dot(dir) < 0.9 then
                local testRay = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), dir * stepSize, rayParams)
                if not testRay then
                    return hrp.Position + dir * stepSize
                end
            end
        end
        return hrp.Position
    else
        return proposedPos
    end
end

local function selectNextStep(hrp, targetPos, lastDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local bestScore = math.huge
    local bestPos, bestDir = nil, nil
    for _, dir in ipairs(scanDirs) do
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local ray = Workspace:Raycast(origin, dir * scanRadiusCurrent, rayParams)
        local pos = ray and ray.Position or origin + dir * scanRadiusCurrent
        if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) then
            pos = avoidWallCollision(hrp, pos)
            local dist = (pos - targetPos).Magnitude
            for _, prevPos in ipairs(lastPositions) do
                if prevPos and (pos - prevPos).Magnitude < stepSize * 0.5 then
                    dist = dist + 20
                end
            end
            local score = dist
            if lastDir and lastDir:Dot(dir) > 0.85 then score = score * 0.6 end
            if score < bestScore then
                bestScore = score
                bestPos = pos
                bestDir = dir
            end
        end
    end
    if bestPos then
        table.insert(lastPositions, bestPos)
        if #lastPositions > 25 then table.remove(lastPositions, 1) end
    end
    return bestPos, bestDir
end

local function predictTargetFuturePosition(tgtHRP, velocityHistory)
    if #velocityHistory < 2 then return tgtHRP.Position end
    local last = velocityHistory[#velocityHistory]
    local prev = velocityHistory[#velocityHistory - 1]
    local dt = last.Time - prev.Time
    if dt <= 0 then return tgtHRP.Position end
    local vel = (last.Position - prev.Position) / dt
    return last.Position + vel * 0.5
end

local function ultraLidarNavigate(hrp, humanoid, targetPos, targetVelHistory)
    moving = true
    local lastDir = nil
    local pathPoints = {hrp.Position}
    lastPositions = {}
    while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
        local predictedPos = targetVelHistory and predictTargetFuturePosition(targetPos, targetVelHistory) or targetPos
        local nextStep, chosenDir = selectNextStep(hrp, predictedPos, lastDir)
        if not nextStep then
            warn("[LIDAR] Нет безопасных путей, застрял?")
            break
        end
        if tryJump(hrp, humanoid, nextStep) then
            task.wait(parkourMode and 0.1 or 0.25)
        end
        humanoid:MoveTo(nextStep)
        humanoid.MoveToFinished:Wait()
        lastDir = chosenDir
        table.insert(pathPoints, nextStep)
        task.wait(updateInterval)
    end
    
    -- отрисовка направления, основной линии отличной синим цветом
    drawColoredScanVisualization(hrp, lastDir or Vector3.new(0,0,1))
    
    moving = false
end

local function clearConnections()
    for _,conn in ipairs(connections) do
        if conn and conn.Connected then conn:Disconnect() end
    end
    connections = {}
end

Plugin.Commands["lidarshowcolors"] = {
    ListName = "lidarshowcolors",
    Description = "Показывает цветные лучи LIDAR: синий - текущий, зелёный - безопасные, красный - опасные",
    Aliases = {},
    Function = function()
        local char, hrp = getCharacter(localPlayer)
        if not hrp then print("[LIDAR] HumanoidRootPart не найден") return end
        local sampleTargetDir = Vector3.new(1,0,0) -- Для примера, перед игроком
        drawColoredScanVisualization(hrp, sampleTargetDir)
        print("[LIDAR] Цветная визуализация выполнена")
    end
}

return Plugin

Цитаты:
[1] IMG_20250817_025546_903.jpg https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/88450565/70f7488d-985e-4f24-8d05-d826d1a3bba2/IMG_20250817_025546_903.jpg
[2] Creating A Plugin https://github.com/EdgeIY/infiniteyield/wiki/Creating-A-Plugin
[3] Adding Commands To A Plugin https://github.com/EdgeIY/infiniteyield/wiki/Adding-Commands-To-A-Plugin
[4] https://github.com/EdgeIY/infiniteyield/
