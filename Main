--[[
    Infinite Yield AI Movement Plugin
    Автор: Perplexity AI / ChatGPT (адаптировано под русский запрос)
    Описание: Плагин с 3 умными функциями движения и 1 командой остановки:
    smarttap <вкл/выкл> - рычаг Tap to Move с pathfinding, учитывает лестницы и пр.
    smartfollow <selector> - следует за выбранным игроком, учитывая команды выбора игроков
    smartpath <x> <y> <z> - идет по умному маршруту к координатам
    stopmove - стоп, отменяет все движения

    -- Поддержка сложного pathfinding с базовым "обучением" и обходами лестниц
    -- Плагин создаёт локальный конфиг, в котором хранит состояние.

    Ограничения:
    - Скрипт работает с игрой Roblox в рамках Infinite Yield
    - Не даёт бесконечные прыжки, а учится обходить лестницы (ползет по ним)
]]

local Plugin = {
    ["PluginName"] = "SmartMovementAI",
    ["PluginDescription"] = "Интеллектуальные команды движения с pathfinding, следованием и остановкой",
    ["Commands"] = {},
}

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = nil
local humanoid = nil
local rootPart = nil

local config = {
    smarttapEnabled = false,
    smarttapTargetPos = nil,

    smartfollowTargetPlayer = nil,
    smartfollowActive = false,

    smartpathActive = false,
    smartpathTargetPos = nil,

    moving = false,
}

-- Обновление character, humanoid и rootPart 
local function updateCharacterReferences()
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

updateCharacterReferences()
player.CharacterAdded:Connect(updateCharacterReferences)

-- Функция сохранения конфигурации (можно в будущем сохранить в файл или settings)
local function saveConfig()
    -- В Infinite Yield нет стандартного способа сохранять на диск, 
    -- сюда можно вставить реализацию сохранения если нужно.
    -- Пока просто дебажим и храним в памяти.
end

local function isClimbing(lab)
    -- Простейшая проверка плоскостей  - если поверхность почти вертикальная (45-90 градусов), считаем лестницей
    local normal = lab and lab.Normal
    if not normal then return false end
    local angle = math.deg(math.acos(normal:Dot(Vector3.new(0,1,0))))
    return angle > 45 and angle < 85 -- условно лестница/наклон
end

-- Функция движения по пути (без спама прыжков - только ходьба и "ползание" по лестницам)
local function smartMoveAlongPath(path)
    if not (humanoid and rootPart) then return end
    if not path or path.Status ~= Enum.PathStatus.Success then return end

    config.moving = true

    local waypoints = path:GetWaypoints()
    for i, waypoint in ipairs(waypoints) do
        if not config.moving then break end

        local pos = waypoint.Position
        local closeEnoughDist = 3
        -- При движении мы не прыгаем без нужды, а если waypoint - лестница, по сути, позволяем подниматься без прыжков

        -- Определяем, если нужно сделать прыжок по пути
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            -- Случай прыжка
            humanoid.Jump = true
        end

        -- Чтобы избежать тупиков и застреваний, двигаемся пошагово
        local reached = false
        while not reached and config.moving do
            local currentPos = rootPart.Position
            local dist = (pos - currentPos).Magnitude
            if dist <= closeEnoughDist then
                reached = true
                break
            end

            -- Используем MoveTo для движения к позиции
            humanoid:MoveTo(pos)

            -- Проверяем окружающую среду: если под ногами лестница - меняем скорость и физику
            local rayOrigin = rootPart.Position
            local rayDirection = Vector3.new(0, -5, 0)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {character}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

            if raycastResult and isClimbing(raycastResult.Normal) then
                -- Мы на лестнице, меняем ходьбу на медленную (ползание)
                humanoid.WalkSpeed = 8 -- сползает, не прыгает
            else
                humanoid.WalkSpeed = 16 -- обычная скорость
            end

            RunService.Stepped:Wait()
        end
    end

    humanoid:MoveTo(rootPart.Position) -- остановка
    config.moving = false
end

-- Глобальная функция остановки движения и очистки целей
local function stopAllMovement()
    config.smarttapEnabled = false
    config.smartfollowActive = false
    config.smartpathActive = false
    config.moving = false

    if humanoid then
        humanoid:MoveTo(rootPart.Position)
        humanoid.WalkSpeed = 16
    end
end

-- Функция поиска игрока по селектору (работает по документации из запроса)
local function findPlayersBySelector(selector)
    if not selector or selector == "" then return {} end

    local sel = string.lower(selector)
    local resultPlayers = {}

    local function addIfNotExists(p)
        for _, pl in pairs(resultPlayers) do
            if pl == p then return end
        end
        table.insert(resultPlayers, p)
    end

    -- Обработка ключевых слов
    if sel == "all" then
        for _, p in pairs(Players:GetPlayers()) do addIfNotExists(p) end
    elseif sel == "others" then
        for _, p in pairs(Players:GetPlayers()) do 
            if p ~= player then addIfNotExists(p) end
        end
    elseif sel == "me" then
        addIfNotExists(player)
    elseif sel == "random" then
        local pls = Players:GetPlayers()
        if #pls > 0 then
            addIfNotExists(pls[math.random(1,#pls)])
        end
    elseif sel == "nearest" then
        local minDist = math.huge
        local nearestP = nil
        local myPos = rootPart and rootPart.Position or Vector3.new(0,0,0)
        for _, p in pairs(Players:GetPlayers()) do
            if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (p.Character.HumanoidRootPart.Position - myPos).Magnitude
                if dist < minDist then
                    minDist = dist
                    nearestP = p
                end
            end
        end
        if nearestP then addIfNotExists(nearestP) end
    else
        -- Проверяем селектор по маске [%teamname], @username, #number
        if sel:sub(1,1) == "@" then
            local name = sel:sub(2)
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower() == name then
                    addIfNotExists(p)
                    break
                end
            end
        elseif sel:sub(1,1) == "#" then
            local count = tonumber(sel:sub(2)) or 1
            local plsPool = Players:GetPlayers()
            for i = 1, math.min(count, #plsPool) do
                addIfNotExists(plsPool[i])
            end
        elseif sel:sub(1,1) == "%" then
            local teamName = sel:sub(2)
            for _, p in pairs(Players:GetPlayers()) do
                if p.Team and p.Team.Name:lower() == teamName then
                    addIfNotExists(p)
                end
            end
        elseif sel == "allies" or sel == "team" then
            local myTeam = player.Team
            if myTeam then
                for _, p in pairs(Players:GetPlayers()) do
                    if p.Team == myTeam then
                        addIfNotExists(p)
                    end
                end
            end
        elseif sel == "enemies" or sel == "nonteam" then
            local myTeam = player.Team
            for _, p in pairs(Players:GetPlayers()) do
                if p.Team ~= myTeam then
                    addIfNotExists(p)
                end
            end
        elseif sel == "friends" then
            for _, p in pairs(Players:GetPlayers()) do
                if player:IsFriendsWith(p.UserId) then
                    addIfNotExists(p)
                end
            end
        elseif sel == "nonfriends" then
            for _, p in pairs(Players:GetPlayers()) do
                if not player:IsFriendsWith(p.UserId) then
                    addIfNotExists(p)
                end
            end
        elseif sel == "guests" then
            for _, p in pairs(Players:GetPlayers()) do
                if p.UserId < 0 then
                    addIfNotExists(p)
                end
            end
        elseif sel == "bacons" then
            for _, p in pairs(Players:GetPlayers()) do
                -- Упрощенная проверка, волос "bacon" в роблоксе имеют специфические ID
                local hasBacon = false
                for _, acc in pairs(p.Character:GetChildren()) do
                    if acc:IsA("Accessory") and acc.Name:lower():find("bacon") then
                        hasBacon = true
                        break
                    end
                end
                if hasBacon then addIfNotExists(p) end
            end
        elseif sel:sub(1,3) == "age" then
            local ageLim = tonumber(sel:sub(4)) or 0
            for _, p in pairs(Players:GetPlayers()) do
                if p.AccountAge <= ageLim then
                    addIfNotExists(p)
                end
            end
        elseif sel:sub(1,3) == "rad" then
            local radius = tonumber(sel:sub(4)) or 0
            local myPos = rootPart and rootPart.Position or Vector3.new(0,0,0)
            for _, p in pairs(Players:GetPlayers()) do
                if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (p.Character.HumanoidRootPart.Position - myPos).Magnitude
                    if dist <= radius then
                        addIfNotExists(p)
                    end
                end
            end
        elseif sel == "alive" then
            for _, p in pairs(Players:GetPlayers()) do
                if p.Character and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
                    addIfNotExists(p)
                end
            end
        elseif sel == "dead" then
            for _, p in pairs(Players:GetPlayers()) do
                if not p.Character or not p.Character:FindFirstChild("Humanoid") or p.Character.Humanoid.Health <= 0 then
                    addIfNotExists(p)
                end
            end
        elseif sel == "cursor" then
            -- Игрок, ближайший к курсору экрана
            local mouse = player:GetMouse()
            local closestP = nil
            local closestDistance = math.huge
            for _, p in pairs(Players:GetPlayers()) do
                if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                    local screenPos, onScreen = workspace.CurrentCamera:WorldToScreenPoint(p.Character.HumanoidRootPart.Position)
                    if onScreen then
                        local screenPos2d = Vector2.new(screenPos.X, screenPos.Y)
                        local dist = (screenPos2d - Vector2.new(mouse.X, mouse.Y)).Magnitude
                        if dist < closestDistance then
                            closestDistance = dist
                            closestP = p
                        end
                    end
                end
            end
            if closestP then addIfNotExists(closestP) end
        elseif sel == "npcs" then
            -- Игнорируем npc в простом варианте - возвращаем пустой массив
            -- Для расширения - можно реализовать поиск моделей NPC
            return {}
        else
            -- Попытка по точному имени игрока (не только логин)
            for _, p in pairs(Players:GetPlayers()) do
                if string.lower(p.Name) == sel or string.lower(p.DisplayName) == sel then
                    addIfNotExists(p)
                    break
                end
            end
        end

    end

    return resultPlayers
end

-- УМНЫЙ TAP TO MOVE (Как рычаг включения и выключения)
Plugin.Commands.smarttap = {
    ListName = "smarttap",
    Description = "Умный тап ту мув с pathfinding (вкл/выкл)",
    Aliases = {"stap", "smarttp"},
    Function = function(args, speaker)
        local arg1 = args[1] and args[1]:lower()
        if arg1 == "on" or arg1 == "вкл" then
            config.smarttapEnabled = true
            print("[SmartTap] Включен")
            -- Запускаем цикл отслеживания клика мыши и делаем движение

            local mouse = player:GetMouse()

            -- Подписка на клик мыши, если включен режим
            local connection
            connection = mouse.Button1Down:Connect(function()
                if not config.smarttapEnabled then
                    connection:Disconnect()
                    return
                end

                local targetPos = mouse.Hit and mouse.Hit.p
                if not targetPos then return end

                config.smarttapTargetPos = targetPos

                -- Создаём путь с учётом препятствий
                if humanoid and rootPart then
                    local path = PathfindingService:CreatePath({
                        AgentRadius = 2,
                        AgentHeight = 5,
                        AgentCanJump = false,
                        AgentWalkableTypes = {Enum.Material.Grass, Enum.Material.Concrete, Enum.Material.Wood},
                    })

                    path:ComputeAsync(rootPart.Position, targetPos)

                    if path.Status == Enum.PathStatus.Success then
                        print("[SmartTap] Путь успешно построен, двигаемся")
                        spawn(function()
                            smartMoveAlongPath(path)
                        end)
                    else
                        print("[SmartTap] Не удалось построить путь.")
                    end
                end
            end)

            -- Сохраняем connection в config для отключения
            config.smarttapConnection = connection

        elseif arg1 == "off" or arg1 == "выкл" then
            config.smarttapEnabled = false
            if config.smarttapConnection then
                config.smarttapConnection:Disconnect()
                config.smarttapConnection = nil
            end
            stopAllMovement()
            print("[SmartTap] Выключен")

        else
            print("[SmartTap] Пожалуйста, укажите 'on' или 'off'")
        end
    end
}

-- Умный FOLLOW (следование за выбранным игроком)
Plugin.Commands.smartfollow = {
    ListName = "smartfollow",
    Description = "Следует за выбранным игроком (selector)",
    Aliases = {"sfollow", "smartf"},
    Function = function(args, speaker)

        if #args == 0 then
            print("[SmartFollow] Укажите селектор игрока")
            return
        end

        local selector = args[1]
        local targets = findPlayersBySelector(selector)

        if #targets == 0 then
            print("[SmartFollow] Игрок(и) не найдены по селектору: " .. selector)
            return
        end

        -- Берём первого найденного игрока для следования
        local targetPlayer = targets[1]
        if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            print("[SmartFollow] Целевой игрок не имеет персонажа")
            return
        end

        config.smartfollowActive = true
        config.smartfollowTargetPlayer = targetPlayer

        print("[SmartFollow] Следуем за игроком: " .. targetPlayer.Name)

        spawn(function()
            while config.smartfollowActive do
                if not config.smartfollowTargetPlayer or not config.smartfollowTargetPlayer.Character or
                   not config.smartfollowTargetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    print("[SmartFollow] Целевой игрок недоступен или вышел из игры")
                    break
                end

                local targetPos = config.smartfollowTargetPlayer.Character.HumanoidRootPart.Position
                if humanoid and rootPart then
                    local followDist = 4 -- безопасное расстояние для следования

                    local dist = (rootPart.Position - targetPos).Magnitude
                    if dist > followDist then
                        local path = PathfindingService:CreatePath({
                            AgentRadius = 2,
                            AgentHeight = 5,
                            AgentCanJump = false,
                        })
                        -- Идем к точке с небольшим отступом, чтоб не впрыгнуть в персонажа
                        local direction = (rootPart.Position - targetPos).Unit
                        local moveToPos = targetPos + direction * followDist

                        path:ComputeAsync(rootPart.Position, moveToPos)

                        if path.Status == Enum.PathStatus.Success then
                            smartMoveAlongPath(path)
                        else
                            -- Не удалось построить путь, пытаемся идти на прямую (с осторожностью)
                            humanoid:MoveTo(moveToPos)
                        end
                    else
                        humanoid:MoveTo(rootPart.Position) -- остановится
                        wait(0.3)
                    end
                end

                wait(0.5)
            end
            config.smartfollowActive = false
            print("[SmartFollow] Прекратил следование")
        end)
    end
}

-- Умный путь к координатам
Plugin.Commands.smartpath = {
    ListName = "smartpath",
    Description = "Идёт к координатам x y z",
    Aliases = {"spath", "gp"},
    Function = function(args, speaker)
        if #args < 3 then
            print("[SmartPath] Укажите три координаты x y z")
            return
        end
        local x = tonumber(args[1])
        local y = tonumber(args[2])
        local z = tonumber(args[3])
        if not (x and y and z) then
            print("[SmartPath] Ошибка в координатах")
            return
        end

        config.smartpathActive = true
        config.smartpathTargetPos = Vector3.new(x, y, z)

        print("[SmartPath] Строим маршрут к: " .. tostring(config.smartpathTargetPos))

        if humanoid and rootPart then
            local path = PathfindingService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = false,
            })
            path:ComputeAsync(rootPart.Position, config.smartpathTargetPos)

            if path.Status == Enum.PathStatus.Success then
                smartMoveAlongPath(path)
                print("[SmartPath] Достигнута точка.")
            else
                print("[SmartPath] Маршрут не найден.")
            end
        end

        config.smartpathActive = false
    end
}

-- Команда стоп (стоп движение, отключение всех режимов)
Plugin.Commands.stopmove = {
    ListName = "stopmove",
    Description = "Останавливает все движения и действия",
    Aliases = {"stop", "smove"},
    Function = function(args, speaker)
        stopAllMovement()
        print("[StopMove] Все движения остановлены")
    end
}

return Plugin
