-- SuperSmartPathfinder with Parkour Toggle Mode
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer

local moving = false
local smartTapEnabled = false
local parkourMode = false -- üéØ Toggle Parkour Mode

local moveConnection = nil
local followConnection = nil
local currentTarget = nil

--------------------------------------------------------
-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
--------------------------------------------------------
local function getCharacter(player)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character,
               player.Character:FindFirstChild("HumanoidRootPart"),
               player.Character:FindFirstChildOfClass("Humanoid")
    end
    return nil, nil, nil
end

-- –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–∏
local function drawPath(waypoints)
    for i = 1, #waypoints - 1 do
        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.CanCollide = false
        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Parent = workspace
        Debris:AddItem(part, 0.5)
    end
end

-- –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—É—Ç–∏
local function computePath(startPos, destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 3,
        Costs = {
            Water = math.huge
        }
    })
    path:ComputeAsync(startPos, destination)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        drawPath(waypoints)
        return waypoints
    else
        warn("[PATHFINDING] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—É—Ç—å: " .. tostring(path.Status))
    end
    return nil
end

--------------------------------------------------------
-- –ü–∞—Ä–∫—É—Ä
--------------------------------------------------------
local function performParkourMove(humanoid, hrp, obstacle)
    if obstacle and obstacle:IsA("BasePart") then
        local posDiff = obstacle.Position.Y - hrp.Position.Y

        -- Edge Grab climb
        if posDiff > 2 and posDiff < 6 then
            humanoid.Jump = true
            task.wait(0.2)
            hrp.CFrame = hrp.CFrame + Vector3.new(0, posDiff + 2, 0)
        elseif posDiff >= 6 and posDiff <= 8 then
            -- WallJump
            humanoid.Jump = true
            task.wait(0.15)
            humanoid:Move(Vector3.new(0, 0, -1))
            task.wait(0.1)
            humanoid.Jump = true
        elseif posDiff > 8 and posDiff < 12 then
            -- Diagonal jump trick
            humanoid.Jump = true
            task.wait(0.1)
            hrp.CFrame = hrp.CFrame + Vector3.new(1.5, 3, 1.5)
        elseif posDiff >= 0 and posDiff <= 2 then
            -- Corner Cut
            humanoid:Move(Vector3.new(1, 0, 1))
        end
    end
end

-- –°–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø–æ –ø—É—Ç–∏ —Å –ø–∞—Ä–∫—É—Ä–æ–º
local function followPathWithParkour(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()

        if not reached then
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {workspace.Terrain, hrp.Parent}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local direction = (waypoint.Position - hrp.Position)
            if direction.Magnitude > 0 then
                local ray = workspace:Raycast(hrp.Position, direction.Unit * 3, params)
                if ray then
                    performParkourMove(humanoid, hrp, ray.Instance)
                end
            end
        end

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end

        task.wait() -- —á—Ç–æ–±—ã –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Ü–∏–∫–ª
    end
    moving = false
end

-- –û–±—ã—á–Ω–æ–µ —Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø–æ –ø—É—Ç–∏
local function followPathNormal(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        humanoid.MoveToFinished:Wait()
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
        task.wait()
    end
    moving = false
end

-- –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –¥–≤–∏–∂–µ–Ω–∏—è
local function followPath(humanoid, hrp, waypoints)
    if parkourMode then
        followPathWithParkour(humanoid, hrp, waypoints)
    else
        followPathNormal(humanoid, hrp, waypoints)
    end
end

--------------------------------------------------------
-- –ö–æ–º–∞–Ω–¥—ã
--------------------------------------------------------
-- SMARTTAP
local function toggleSmartTap()
    smartTapEnabled = not smartTapEnabled
    if smartTapEnabled then
        print("[üß† SMARTTAP] –í–∫–ª—é—á–µ–Ω, –∫–ª–∏–∫–∞–π—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ!")
        moveConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mouse = localPlayer:GetMouse()
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    local path = computePath(hrp.Position, mouse.Hit.p)
                    if path then
                        followPath(humanoid, hrp, path)
                    else
                        warn("[SMARTTAP] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—É—Ç—å.")
                    end
                end
            end
        end)
    else
        print("[üõë SMARTTAP] –í—ã–∫–ª—é—á–µ–Ω.")
        if moveConnection then
            moveConnection:Disconnect()
            moveConnection = nil
        end
    end
end

-- SMARTFOLLOW
local function smartFollow(targetFilter)
    if followConnection then
        followConnection:Disconnect()
        followConnection = nil
    end

    local targetPlayers
    if _G.getPlayer then
        targetPlayers = _G.getPlayer(targetFilter)
    else
        -- fallback - –ø–æ–∏—Å–∫ –∏–≥—Ä–æ–∫–∞ –ø–æ –∏–º–µ–Ω–∏ —Å—Ä–µ–¥–∏ –≤—Å–µ—Ö
        targetPlayers = {}
        if targetFilter == "nearest" then
            local shortestDist = math.huge
            local nearest = nil
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    if dist < shortestDist then
                        nearest = player
                        shortestDist = dist
                    end
                end
            end
            if nearest then
                targetPlayers = {nearest}
            end
        else
            for _, player in pairs(Players:GetPlayers()) do
                if player.Name:lower():find(targetFilter:lower()) then
                    table.insert(targetPlayers, player)
                end
            end
        end
    end

    if #targetPlayers == 0 then
        warn("[‚ö† SMARTFOLLOW] –ò–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    end
    currentTarget = targetPlayers[1]
    print("[üß† SMARTFOLLOW] –°–ª–µ–¥—É—é –∑–∞: " .. currentTarget.Name .. (parkourMode and " (–ü–∞—Ä–∫—É—Ä)" or ""))

    followConnection = RunService.Heartbeat:Connect(function()
        if not moving and currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild("HumanoidRootPart") then
            local char, hrp, humanoid = getCharacter(localPlayer)
            local targetChar, targetHRP = currentTarget.Character, currentTarget.Character:FindFirstChild("HumanoidRootPart")
            if char and hrp and humanoid and targetChar and targetHRP then
                local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.5)
                local path = computePath(hrp.Position, predictedPos)
                if path then
                    followPath(humanoid, hrp, path)
                end
            end
        end
    end)
end

-- SMARTPATH
local function smartPathXYZ(args)
    if #args < 3 then
        warn("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: smartpath X Y Z")
        return
    end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if char and hrp and humanoid then
        local x, y, z = tonumber(args[1]), tonumber(args), tonumber(args)
        if x and y and z then
            local goal = Vector3.new(x, y, z)
            local path = computePath(hrp.Position, goal)
            if path then
                followPath(humanoid, hrp, path)
            else
                warn("[SMARTPATH] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—É—Ç—å.")
            end
        else
            warn("[SMARTPATH] –ù–µ–≤–µ—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã.")
        end
    end
end

-- TOGGLE PARKOUR MODE
local function toggleParkour()
    parkourMode = not parkourMode
    print(parkourMode and "[ü§∏‚Äç‚ôÇÔ∏è PARKOUR MODE] –í–∫–ª—é—á–µ–Ω" or "[üö∂‚Äç‚ôÇÔ∏è PARKOUR MODE] –í—ã–∫–ª—é—á–µ–Ω")
end

-- STOPMOVE
local function stopMoving()
    moving = false
    if followConnection then
        followConnection:Disconnect()
        followConnection = nil
    end
    if moveConnection then
        moveConnection:Disconnect()
        moveConnection = nil
    end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if humanoid then
        humanoid:Move(Vector3.new(0, 0, 0))
    end
    print("[üõë STOPMOVE] –î–≤–∏–∂–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.")
end

--------------------------------------------------------
-- –ü–ª–∞–≥–∏–Ω Infinite Yield
--------------------------------------------------------
local Plugin = {
    PluginName = "SuperSmartPathfinder",
    PluginDescription = "Baritone-—É—Ä–æ–≤–µ–Ω—å Pathfinding —Å toggle –ü–∞—Ä–∫—É—Ä–æ–º –¥–ª—è Roblox",
    Commands = {
        smarttap = {
            ListName = "smarttap",
            Description = "–í–∫–ª—é—á–∞–µ—Ç/–≤—ã–∫–ª—é—á–∞–µ—Ç —É–º–Ω–æ–µ Tap-to-Move",
            Function = function(args, speaker)
                toggleSmartTap()
            end
        },
        smartfollow = {
            ListName = "smartfollow",
            Description = "–°–ª–µ–¥—É–µ—Ç –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–º –∏–≥—Ä–æ–∫–æ–º",
            Function = function(args, speaker)
                smartFollow(args[1] or "nearest")
            end
        },
        smartpath = {
            ListName = "smartpath",
            Description = "–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—É—Ç–∏ –∫ –∑–∞–¥–∞–Ω–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º",
            Function = function(args, speaker)
                smartPathXYZ(args)
            end
        },
        parkourmode = {
            ListName = "parkourmode",
            Description = "–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º –ø–∞—Ä–∫—É—Ä–∞",
            Function = function(args, speaker)
                toggleParkour()
            end
        },
        stopmove = {
            ListName = "stopmove",
            Description = "–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ª—é–±–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ",
            Function = function(args, speaker)
                stopMoving()
            end
        }
    }
}

return Plugin
