я же сказал избегать столкновений в объектами, ало, и чтоб все лучи были направлены в разные стороны В ОДНО ВРЕМЯ, а не они смотрели одну и ту же точку по 200 лучей, просто дай всем лучам разное направление в одно время, и вкачай ему ум опять, на всякий случай, дай ему возможность перепрыгивать вещи и обходить всё, и сделай опять линии длиннее, но с условием, что если персонаж почти вплотную к стене, то он обходит в свободном направлении, а то это пизда какая то, ну короче да, если вообще возможно, дай ему возможность обучаться на определённой карте, за счёт lidarrandom, пусть патрулирует узнаёт новые лазейки

вот документации infinite yield про плагины:
https://github.com/EdgeIY/infiniteyield/wiki/Creating-A-Plugin
https://github.com/EdgeIY/infiniteyield/wiki/Adding-Commands-To-A-Plugin
https://github.com/EdgeIY/infiniteyield/wiki/Infinite-Yield's-Core-Functions
https://github.com/EdgeIY/infiniteyield/wiki/Loading-Plugin

local Plugin = {
    PluginName = "SmartLidarNavigatorPlus",
    PluginDescription = "Умный LIDAR навигатор с безошибочным обходом стен, динамическим распределением лучей, паркуром и обучением через патрулирование",
    Commands = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local parkourMode = false
local followMode = nil
local currentTarget = nil
local connections = {}

local scanRadius = 100
local safeDistance = 4
local maxJumpHeight = 7
local updateInterval = 0.012
local rayCountBase = 400
local rayCountParkour = 800

local dangerTags = {"Damage", "Lava", "Fire", "Kill", "Trap", "Spike", "Acid", "Death"}

local mapKnowledge = {}

local function getCharacter(player)
    if not player then return nil,nil,nil end
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character, player.Character.HumanoidRootPart, player.Character:FindFirstChildOfClass("Humanoid")
    end
    return nil,nil,nil
end

local function isDangerPart(part)
    if not part or not part:IsA("BasePart") then return false end
    local name = part.Name:lower()
    for _, tag in pairs(dangerTags) do
        if name:find(tag:lower()) then return true end
    end
    if part:GetAttribute("Danger") == true then return true end
    return false
end

local function checkDangerNearby(pos, radius)
    local region = Region3.new(pos - Vector3.new(radius,radius,radius), pos + Vector3.new(radius,radius,radius))
    local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {localPlayer.Character}, 50)
    for _, part in pairs(parts) do
        if isDangerPart(part) then return true end
    end
    return false
end

local function isPathDangerous(startPos, endPos, excludeModel)
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {excludeModel}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), direction * distance, rayParams)
    if ray and isDangerPart(ray.Instance) then return true end
    return false
end

-- Генерируем уникальные разнонаправленные лучи для покрытия всей сферы
local function generateDistributedScanDirs(rayCount)
    local dirs = {}
    local goldenRatio = (1 + math.sqrt(5)) / 2
    for i = 0, rayCount - 1 do
        local theta = 2 * math.pi * i / goldenRatio
        local phi = math.acos(1 - 2 * (i + 0.5) / rayCount)
        local x = math.sin(phi) * math.cos(theta)
        local y = math.sin(phi) * math.sin(theta)
        local z = math.cos(phi)
        table.insert(dirs, Vector3.new(x, y, z))
    end
    return dirs
end

local scanDirs = generateDistributedScanDirs(rayCountBase)

local function updateScanSettings()
    if parkourMode then
        scanDirs = generateDistributedScanDirs(rayCountParkour)
        scanRadius = 120
        updateInterval = 0.008
    else
        scanDirs = generateDistributedScanDirs(rayCountBase)
        scanRadius = 100
        updateInterval = 0.012
    end
end

local lastPositions = {}
local stepSize = 8

local function avoidWallClashing(hrp, proposedPos)
    local character = hrp.Parent
    if not character then return proposedPos end
    local dirToProposed = (proposedPos - hrp.Position).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), dirToProposed * stepSize, rayParams)
    if ray and ray.Instance and not isDangerPart(ray.Instance) then
        -- Обходим направление вперед и ищем более свободное направление
        for _, dir in ipairs(scanDirs) do
            local testRay = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), dir * stepSize, rayParams)
            if not testRay and dir ~= dirToProposed then
                return hrp.Position + dir * stepSize
            end
        end
        -- Если нет альтернативы, остаемся
        return hrp.Position
    else
        return proposedPos
    end
end

local function drawPath(points, color)
    color = color or Color3.new(0.3, 0.7, 1)
    for i=1, #points-1 do
        local p1, p2 = points[i], points[i+1]
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.18, 0.18, (p1-p2).Magnitude)
        part.CFrame = CFrame.new((p1+p2)/2, p2)
        part.Material = Enum.Material.Neon
        part.Color = color
        part.Parent = Workspace
        Debris:AddItem(part, 3)
    end
end

local function tryJump(hrp, humanoid, nextPoint)
    local yd = nextPoint.Y - hrp.Position.Y
    if yd > 1.5 and yd < maxJumpHeight and humanoid and humanoid.FloorMaterial ~= Enum.Material.Air then
        humanoid.Jump = true
        task.wait(0.2)
        return true
    end
    return false
end

local function selectNextStep(hrp, targetPos, lastDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local bestScore = math.huge
    local bestPos, bestDir = nil, nil

    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {hrp.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    for _, dir in ipairs(scanDirs) do
        local ray = Workspace:Raycast(origin, dir * scanRadius, rayParams)
        local pos = ray and ray.Position or origin + dir * scanRadius
        if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) then
            pos = avoidWallClashing(hrp, pos)
            local dist = (pos - targetPos).Magnitude
            for _, prevPos in ipairs(lastPositions) do
                if prevPos and (pos - prevPos).Magnitude < stepSize * 0.5 then
                    dist = dist + 10
                end
            end
            local score = dist
            if lastDir and lastDir:Dot(dir) > 0.85 then
                score = score * 0.65
            end
            if score < bestScore then
                bestScore = score
                bestPos = pos
                bestDir = dir
            end
        end
    end

    if bestPos then
        table.insert(lastPositions, bestPos)
        if #lastPositions > 20 then
            table.remove(lastPositions, 1)
        end
    end
    return bestPos, bestDir
end

local function predictTargetFuturePosition(tgtHRP, velocityHistory)
    if #velocityHistory < 2 then return tgtHRP.Position end
    local last = velocityHistory[#velocityHistory]
    local prev = velocityHistory[#velocityHistory-1]
    local dt = last.Time - prev.Time
    if dt <= 0 then return tgtHRP.Position end
    local vel = (last.Position - prev.Position)/dt
    return last.Position + vel * 0.5
end

local function ultraLidarNavigate(hrp, humanoid, targetPos, targetVelHistory)
    moving = true
    local lastDir = nil
    local pathPoints = {hrp.Position}
    lastPositions = {}

    while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
        local predictedPos = targetVelHistory and predictTargetFuturePosition(targetPos, targetVelHistory) or targetPos
        local nextStep, chosenDir = selectNextStep(hrp, predictedPos, lastDir)
        if not nextStep then
            warn("[LIDAR] Нет безопасных путей, возможно застрял!")
            break
        end

        if tryJump(hrp, humanoid, nextStep) then
            task.wait(parkourMode and 0.1 or 0.25)
        end

        humanoid:MoveTo(nextStep)
        humanoid.MoveToFinished:Wait()

        lastDir = chosenDir
        table.insert(pathPoints, nextStep)
        task.wait(updateInterval)
    end
    drawPath(pathPoints, Color3.fromRGB(0, 150, 255))
    moving = false
    -- Запись пройденных точек для обучения карты
    for _, point in ipairs(pathPoints) do
        local key = string.format("%.2f_%.2f_%.2f", point.X, point.Y, point.Z)
        mapKnowledge[key] = true
    end
end

local function drawScanVisualization(hrp)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    for _, dir in ipairs(scanDirs) do
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local ray = Workspace:Raycast(origin, dir * scanRadius, rayParams)
        local endPos = ray and ray.Position or origin + dir * scanRadius
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.06, 0.06, (endPos - origin).Magnitude)
        part.CFrame = CFrame.new((origin + endPos) / 2, endPos)
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.Parent = Workspace
        Debris:AddItem(part, 1)
    end
end

local function clearConnections()
    for _, conn in ipairs(connections) do
        if conn and conn.Connected then
            conn:Disconnect()
        end
    end
    connections = {}
end

Plugin.Commands["lidartap"] = {
    ListName = "lidartap",
    Description = "Перемещение к точке ПКМ с LIDAR навигацией, без ударов об стены",
    Aliases = {},
    Function = function(args, speaker)
        if followMode == "lidartap" then
            clearConnections()
            moving = false
            followMode = nil
            print("[LIDAR] lidartap выключен")
            return
        end
        updateScanSettings()
        followMode = "lidartap"
        print("[LIDAR] lidartap включен, кликайте ПКМ для движения")
        local conn = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                if moving then return end
                local mouse = localPlayer:GetMouse()
                local destination = mouse.Hit.p
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    coroutine.wrap(function()
                        ultraLidarNavigate(hrp, humanoid, destination)
                    end)()
                end
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["lidarfollow"] = {
    ListName = "lidarfollow [player]",
    Description = "Следовать за игроком с адаптивным LIDAR и обходом препятствий",
    Aliases = {},
    Function = function(args, speaker)
        clearConnections()
        local Players = game:GetService("Players")
        local targetFilter = args and args[1] or "nearest"
        local targetPlayers = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(targetFilter:lower()) then
                table.insert(targetPlayers, p)
            end
        end
        if #targetPlayers == 0 then
            warn("[LIDAR] Цель не найдена")
            return
        end
        currentTarget = targetPlayers[1]
        updateScanSettings()
        followMode = "lidarfollow"
        print("[LIDAR] Следую за "..currentTarget.Name)
        local conn = RunService.Heartbeat:Connect(function()
            if moving then return end
            if not currentTarget or not currentTarget.Character then return end
            local char, hrp, humanoid = getCharacter(localPlayer)
            local tgtChar, tgtHRP = getCharacter(currentTarget)
            if char and hrp and humanoid and tgtChar and tgtHRP then
                coroutine.wrap(function()
                    ultraLidarNavigate(hrp, humanoid, tgtHRP.Position)
                end)()
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["lidarchase"] = {
    ListName = "lidarchase [player]",
    Description = "Преследовать игрока активно, прогнозируя позиции, паркур и интеллектуальный обход",
    Aliases = {},
    Function = function(args, speaker)
        clearConnections()
        local Players = game:GetService("Players")
        local targetFilter = args and args[1] or "nearest"
        local targetPlayers = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(targetFilter:lower()) then
                table.insert(targetPlayers, p)
            end
        end
        if #targetPlayers == 0 then
            warn("[LIDAR] Цель не найдена")
            return
        end
        currentTarget = targetPlayers[1]
        parkourMode = true
        updateScanSettings()
        followMode = "lidarchase"
        print("[LIDAR] Преследую "..currentTarget.Name)
        local targetVelHistory = {}
        local conn = RunService.Heartbeat:Connect(function()
            if moving then return end
            if not currentTarget or not currentTarget.Character then return end
            local tgtHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
            if not tgtHRP then return end
            table.insert(targetVelHistory, {Position = tgtHRP.Position, Time = os.clock()})
            if #targetVelHistory > 15 then table.remove(targetVelHistory,1) end
            local char, hrp, humanoid = getCharacter(localPlayer)
            if char and hrp and humanoid then
                coroutine.wrap(function()
                    ultraLidarNavigate(hrp, humanoid, tgtHRP.Position, targetVelHistory)
                end)()
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["parkourmode"] = {
    ListName = "parkourmode",
    Description = "Вкл/выкл расширенный паркур режим",
    Aliases = {},
    Function = function()
        parkourMode = not parkourMode
        updateScanSettings()
        print(parkourMode and "[LIDAR] Паркур включен" or "[LIDAR] Паркур выключен")
    end
}

Plugin.Commands["lidarrandom"] = {
    ListName = "lidarrandom",
    Description = "Интеллектуальное случайное патрулирование с обучением и обходом",
    Aliases = {},
    Function = function()
        clearConnections()
        followMode = "lidarrandom"
        print("[LIDAR] Включено интеллектуальное случайное патрулирование")
        local char, hrp, humanoid = getCharacter(localPlayer)
        if not char or not hrp or not humanoid then return end
        moving = true
        coroutine.wrap(function()
            local recentPoses = {}
            while moving do
                -- Случайная цель с учётом избегания коллизий
                local tries = 0
                local bestPos
                repeat
                    local randDir = Vector3.new(math.random()*2-1, math.random()*0.4-0.2, math.random()*2-1).Unit
                    local randDist = math.random(20, 70)
                    bestPos = hrp.Position + randDir * randDist

                    local safe = not checkDangerNearby(bestPos, safeDistance) and not isPathDangerous(hrp.Position + Vector3.new(0,2,0), bestPos, hrp.Parent)
                    tries = tries + 1
                    if tries > 20 then break end
                until safe
                if bestPos then
                    ultraLidarNavigate(hrp, humanoid, bestPos)
                    -- Запоминаем изученные точки
                    local key = string.format("%.2f_%.2f_%.2f", bestPos.X, bestPos.Y, bestPos.Z)
                    mapKnowledge[key] = true
                end
                task.wait(0.3)
            end
        end)()
    end
}

Plugin.Commands["lidarshow"] = {
    ListName = "lidarshow",
    Description = "Визуализация 3D LIDAR лучей",
    Aliases = {},
    Function = function()
        local char, hrp = getCharacter(localPlayer)
        if not hrp then
            print("[LIDAR] HumanoidRootPart не найден")
            return
        end
        drawScanVisualization(hrp)
        print("[LIDAR] Визуализация выполнена")
    end
}

Plugin.Commands["lidarstop"] = {
    ListName = "lidarstop",
    Description = "Остановить всю навигацию и движение",
    Aliases = {"stop"},
    Function = function()
        clearConnections()
        moving = false
        parkourMode = false
        followMode = nil
        currentTarget = nil
        local char, hrp, humanoid = getCharacter(localPlayer)
        if humanoid then humanoid:Move(Vector3.new()) end
        print("[LIDAR] Навигация остановлена")
    end
}

return Plugin

Цитаты:
[1] IMG_20250817_025546_903.jpg https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/88450565/70f7488d-985e-4f24-8d05-d826d1a3bba2/IMG_20250817_025546_903.jpg