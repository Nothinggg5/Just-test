Приношу извинения за недоразумение. Давайте напишем скрипт с нуля, который будет включать в себя все требуемые функции, включая глобальный переключатель режима паркура. Вот обновленный скрипт:

```lua
-- SuperSmartPathfinder with Parkour Toggle Mode
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local smartTapEnabled = false
local parkourMode = false -- 🎯 Toggle Parkour Mode
local moveConnection = nil
local followConnection = nil
local currentTarget = nil

--------------------------------------------------------
-- Вспомогательные функции
--------------------------------------------------------
local function getCharacter(player)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character,
               player.Character:FindFirstChild("HumanoidRootPart"),
               player.Character:FindFirstChild("Humanoid")
    end
    return nil, nil, nil
end

-- Визуализация пути
local function drawPath(waypoints)
    for i = 1, #waypoints - 1 do
        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.CanCollide = false
        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Parent = workspace
        Debris:AddItem(part, 0.5)
    end
end

-- Построение пути
local function computePath(startPos, destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 3,
        Costs = {
            Water = math.huge
        }
    })
    path:ComputeAsync(startPos, destination)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        drawPath(waypoints)
        return waypoints
    end
    return nil
end

--------------------------------------------------------
-- Паркур
--------------------------------------------------------
local function performParkourMove(humanoid, hrp, obstacle)
    if obstacle and obstacle:IsA("BasePart") then
        local posDiff = obstacle.Position.Y - hrp.Position.Y

        -- Edge Grab climb
        if posDiff > 2 and posDiff < 6 then
            humanoid.Jump = true
            task.wait(0.2)
            hrp.CFrame = hrp.CFrame * CFrame.new(0, posDiff + 2, 0)
        end

        -- WallJump
        if posDiff >= 6 and posDiff <= 8 then
            humanoid.Jump = true
            task.wait(0.15)
            humanoid:Move(Vector3.new(0, 0, -1))
            task.wait(0.1)
            humanoid.Jump = true
        end

        -- Diagonal jump trick
        if posDiff > 8 and posDiff < 12 then
            humanoid.Jump = true
            task.wait(0.1)
            hrp.CFrame = hrp.CFrame * CFrame.new(1.5, 3, 1.5)
        end

        -- Corner Cut
        if posDiff >= 0 and posDiff <= 2 then
            humanoid:Move(Vector3.new(1, 0, 1))
        end
    end
end

-- Следование по пути с паркуром
local function followPathWithParkour(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()

        if not reached then
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {workspace.Terrain, hrp.Parent}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local ray = workspace:Raycast(hrp.Position, (waypoint.Position - hrp.Position).Unit * 3, params)

            if ray then
                performParkourMove(humanoid, hrp, ray.Instance)
            end
        end

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
    end
    moving = false
end

-- Обычное следование по пути
local function followPathNormal(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        humanoid.MoveToFinished:Wait()
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
    end
    moving = false
end

-- Выбор режима движения
local function followPath(humanoid, hrp, waypoints)
    if parkourMode then
        followPathWithParkour(humanoid, hrp, waypoints)
    else
        followPathNormal(humanoid, hrp, waypoints)
    end
end

--------------------------------------------------------
-- Команды
--------------------------------------------------------
-- SMARTTAP
local function toggleSmartTap()
    smartTapEnabled = not smartTapEnabled
    if smartTapEnabled then
        print("[🧠 SMARTTAP] Включен, кликайте по карте!")
        moveConnection = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mouse = localPlayer:GetMouse()
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    local path = computePath(hrp.Position, mouse.Hit.Position)
                    if path then followPath(humanoid, hrp, path) end
                end
            end
        end)
    else
        print("[🛑 SMARTTAP] Выключен.")
        if moveConnection then moveConnection:Disconnect() end
    end
end

-- SMARTFOLLOW
local function smartFollow(targetFilter)
    if followConnection then followConnection:Disconnect() end
    local targetPlayers = _G.getPlayer(targetFilter)
    if #targetPlayers == 0 then
        warn("[⚠ SMARTFOLLOW] Игрок не найден.")
        return
    end
    currentTarget = targetPlayers[1]
    print("[🧠 SMARTFOLLOW] Следование за:", currentTarget.Name, parkourMode and "(Паркур)" or "")

    followConnection = RunService.Heartbeat:Connect(function()
        if not moving and currentTarget then
            local char, hrp, humanoid = getCharacter(localPlayer)
            local targetChar, targetHRP = getCharacter(currentTarget)
            if char and hrp and humanoid and targetChar and targetHRP then
                local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.5)
                local path = computePath(hrp.Position, predictedPos)
                if path then followPath(humanoid, hrp, path) end
            end
        end
    end)
end

-- SMARTPATH
local function smartPathXYZ(args)
    if #args < 3 then
        warn("Использование: smartpath X Y Z")
        return
    end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if char and hrp and humanoid then
        local x, y, z = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
        if x and y and z then
            local goal = Vector3.new(x, y, z)
            local path = computePath(hrp.Position, goal)
            if path then followPath(humanoid, hrp, path) end
        end
    end
end

-- TOGGLE PARKOUR MODE
local function toggleParkour()
    parkourMode = not parkourMode
    print(parkourMode and "[🤸‍♂️ PARKOUR MODE] Включен" or "[🚶‍♂️ PARKOUR MODE] Выключен")
end

-- STOPMOVE
local function stopMoving()
    moving = false
    if followConnection then followConnection:Disconnect() end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if humanoid then
        humanoid:Move(Vector3.new())
    end
    print("[🛑 STOPMOVE] Движение остановлено.")
end

--------------------------------------------------------
-- Плагин Infinite Yield
--------------------------------------------------------
local Plugin = {
    ["PluginName"] = "SuperSmartPathfinder",
    ["PluginDescription"] = "Baritone-уровень Pathfinding с toggle Паркуром для Roblox",
    ["Commands"] = {
        ["smarttap"] = {
            ["ListName"] = "smarttap",
            ["Description"] = "Включает/выключает умное Tap-to-Move",
            ["Function"] = function(args, speaker)
                toggleSmartTap()
            end
        },
        ["smartfollow"] = {
            ["ListName"] = "smartfollow",
            ["Description"] = "Следует за указанным игроком",
            ["Function"] = function(args, speaker)
                smartFollow(args[1] or "nearest")
            end
        },
        ["smartpath"] = {
            ["ListName"] = "smartpath",
            ["Description"] = "Построение пути к заданным координатам",
            ["Function"] = function(args, speaker)
                smartPathXYZ(args)
            end
        },
        ["parkourmode"] = {
            ["ListName"] = "parkourmode",
            ["Description"] = "Переключает режим паркура",
            ["Function"] = function(args, speaker)
                toggleParkour()
            end
        },
        ["stopmove"] = {
            ["ListName"] = "stopmove",
            ["Description"] = "Останавливает любое движение",
            ["Function"] = function(args, speaker)
                stopMoving()
            end
        }
    }
}

return Plugin
```

Этот скрипт включает все необходимые функции и команды, включая глобальный переключатель режима паркура (`parkourmode`), который влияет на поведение `smarttap`, `smartfollow`, и `smartpath`. Убедитесь, что функция `_G.getPlayer` корректно реализована в вашем окружении Infinite Yield для поиска игроков по фильтру в команде `smartfollow`. Если у вас возникнут проблемы с этой функцией или другими частями скрипта, пожалуйста, уточните.