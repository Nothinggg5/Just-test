ЕБЛАН ВЕРНИ ЭТУ ГЕНЕРАЦИЮ ЛУЧЕЙ, ОНА ПИЗЖЕ: 
local function generateSpherePoints(radius, steps)
    local points = {}
    for i = 0, steps do
        local theta = math.pi * i / steps
        for j = 0, 2 * steps do
            local phi = 2 * math.pi * j / (2 * steps)
            local x = radius * math.sin(theta) * math.cos(phi)
            local y = radius * math.cos(theta)
            local z = radius * math.sin(theta) * math.sin(phi)
            table.insert(points, Vector3.new(x, y, z))







































        end
    end
    return points
end

local scanPoints = generateSpherePoints(scanRadius, 15) -- генерация точек на сфере с распределением






















local function selectNextStepAmbient(hrp, targetPos, lastDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local bestScore = math.huge
    local bestPos, bestDir = nil, nil

    for _, offset in ipairs(scanPoints) do
        local pos = origin + offset



        if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) then

            local dist = (pos - targetPos).Magnitude





            local score = dist
            if lastDir and lastDir:Dot(offset.Unit) > 0.85 then
                score = score * 0.7
            end
            if score < bestScore then
                bestScore = score
                bestPos = pos
                bestDir = offset.Unit
            end
        end
    end






    return bestPos, bestDir
end

local lastPositions = {}
local function tryJump(hrp, humanoid, nextPoint)
    local yd = nextPoint.Y - hrp.Position.Y
    if yd > 1.5 and yd < maxJumpHeight and humanoid and humanoid.FloorMaterial ~= Enum.Material.Air then
        humanoid.Jump = true
        task.wait(0.2)
        return true
    end
    return false
end

local function ultraLidarNavigate(hrp, humanoid, targetPos)
    moving = true
    local lastDir = nil
    local pathPoints = {hrp.Position}
    lastPositions = {}

    while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
        local nextStep, chosenDir = selectNextStepAmbient(hrp, targetPos, lastDir)

        if not nextStep then
            warn("[LIDAR] Нет безопасных путей!")
            break
        end

        if tryJump(hrp, humanoid, nextStep) then
            task.wait(parkourMode and 0.1 or 0.25)
        end

        humanoid:MoveTo(nextStep)
        humanoid.MoveToFinished:Wait()

        lastDir = chosenDir
        table.insert(pathPoints, nextStep)
        task.wait(updateInterval)
    end

local Plugin = {
    PluginName = "UltimateAdaptiveLidarNavigator",
    PluginDescription = "Высокоточный LIDAR навигатор с адаптивным обходом, улучшенными преследованием и обучением, паркуром.",
    Commands = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local parkourMode = false
local followMode = nil
local currentTarget = nil
local connections = {}

local scanRadiusBase = 150
local safeDistance = 4
local maxJumpHeight = 9
local updateIntervalBase = 0.01

local dangerTags = {"damage", "lava", "fire", "kill", "trap", "spike", "acid", "death"}

local function getCharacter(player)
    if not player or not player.Character then return nil,nil,nil end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return player.Character, hrp, humanoid
end

local function isDangerPart(part)
    if not part or not part:IsA("BasePart") then return false end
    local name = part.Name:lower()
    for _, t in pairs(dangerTags) do
        if name:find(t) then return true end
    end
    if part:GetAttribute("Danger") == true then return true end
    return false
end

local function checkDangerNearby(pos, radius)
    local region = Region3.new(pos - Vector3.new(radius,radius,radius), pos + Vector3.new(radius,radius,radius))
    local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {localPlayer.Character}, 50)
    for _, p in pairs(parts) do
        if isDangerPart(p) then return true end
    end
    return false
end

local function isPathDangerous(startPos, endPos, excludeModel)
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {excludeModel}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), direction * distance, rayParams)
    if ray and isDangerPart(ray.Instance) then return true end
    return false
end

local function generateSpherePoints(radius, steps)
    local points = {}
    for i = 0, steps do
        local theta = math.pi * i / steps
        for j = 0, 2 * steps do
            local phi = 2 * math.pi * j / (2 * steps)
            local x = radius * math.sin(theta) * math.cos(phi)
            local y = radius * math.cos(theta)
            local z = radius * math.sin(theta) * math.sin(phi)
            table.insert(points, Vector3.new(x, y, z))
        end
    end
    return points
end

local scanPoints = generateSpherePoints(scanRadiusBase, 15)

local lastPositions = {}
local stepSize = 9

local function avoidObstacles(hrp, proposedPos)
    local character = hrp.Parent
    if not character then return proposedPos end
    local dir = (proposedPos - hrp.Position).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), dir * stepSize, rayParams)
    if ray and ray.Instance and not isDangerPart(ray.Instance) then
        for _, altDir in ipairs(scanPoints) do
            if dir:Dot(altDir.Unit) < 0.9 then
                local testRay = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), altDir.Unit * stepSize, rayParams)
                if not testRay then
                    return hrp.Position + altDir.Unit * stepSize
                end
            end
        end
        return hrp.Position
    else
        return proposedPos
    end
end

local function selectNextStepAmbient(hrp, targetPos, lastDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local bestScore = math.huge
    local bestPos, bestDir = nil, nil
    for _, offset in ipairs(scanPoints) do
        local pos = origin + offset
        if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) then
            pos = avoidObstacles(hrp, pos)
            local dist = (pos - targetPos).Magnitude
            for _, prevPos in ipairs(lastPositions) do
                if prevPos and (pos - prevPos).Magnitude < stepSize * 0.55 then
                    dist = dist + 20
                end
            end
            local score = dist
            if lastDir and lastDir:Dot(offset.Unit) > 0.85 then
                score = score * 0.65
            end
            if score < bestScore then
                bestScore = score
                bestPos = pos
                bestDir = offset.Unit
            end
        end
    end
    if bestPos then
        table.insert(lastPositions, bestPos)
        if #lastPositions > 30 then
            table.remove(lastPositions, 1)
        end
    end
    return bestPos, bestDir
end

local function enhancedJump(hrp, humanoid, nextPoint)
    if not nextPoint or not humanoid then return false end
    if humanoid.FloorMaterial == Enum.Material.Air then return false end
    local heightDiff = nextPoint.Y - hrp.Position.Y
    if heightDiff > 1.4 and heightDiff < maxJumpHeight then
        local origin = hrp.Position + Vector3.new(0, 1.5, 0)
        local forward = (nextPoint - hrp.Position).Unit
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local rectHit = Workspace:Raycast(origin, forward * stepSize, rayParams)
        local ceilingHit = Workspace:Raycast(hrp.Position + Vector3.new(0, 3, 0), forward * stepSize, rayParams)
        if rectHit and not isDangerPart(rectHit.Instance) and not ceilingHit then
            humanoid.Jump = true
            task.wait(0.3)
            return true
        end
    end
    return false
end

local function ultraLidarNavigate(hrp, humanoid, targetPos)
    moving = true
    local lastDir = nil
    local pathPoints = {hrp.Position}
    lastPositions = {}
    while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
        local nextStep, chosenDir = selectNextStepAmbient(hrp, targetPos, lastDir)
        if not nextStep then
            warn("[LIDAR] Нет безопасных путей - возможно застрял")
            break
        end
        if enhancedJump(hrp, humanoid, nextStep) then
            task.wait(parkourMode and 0.1 or 0.25)
        end
        humanoid:MoveTo(nextStep)
        humanoid.MoveToFinished:Wait()
        lastDir = chosenDir
        table.insert(pathPoints, nextStep)
        task.wait(updateIntervalBase)
    end
    -- Рисуем линию пути
    for i=1, #pathPoints-1 do
        local p1, p2 = pathPoints[i], pathPoints[i+1]
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.2, 0.2, (p1-p2).Magnitude)
        part.CFrame = CFrame.new((p1+p2)/2, p2)
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(60, 180, 255)
        part.Parent = Workspace
        Debris:AddItem(part, 4)
    end
    moving = false
end

local function clearConnections()
    for _, conn in ipairs(connections) do
        if conn and conn.Connected then conn:Disconnect() end
    end
    connections = {}
    lastPositions = {}
end

local exploredMap = {}

-- Обучение карты с расширением посещённых зон
local function markExplored(pos)
    local key = string.format("%.1f_%.1f_%.1f", pos.X, pos.Y, pos.Z)
    exploredMap[key] = true
end

local function isExplored(pos)
    local key = string.format("%.1f_%.1f_%.1f", pos.X, pos.Y, pos.Z)
    return exploredMap[key] or false
end

Plugin.Commands["lidarrandom"] = {
    ListName = "lidarrandom",
    Description = "Обучающее случайное патрулирование, избегающее топтания, с расширяющейся картой",
    Aliases = {},
    Function = function()
        clearConnections()
        followMode = "lidarrandom"
        print("[LIDAR] Умное случайное патрулирование с обучением карты включено")
        local char, hrp, humanoid = getCharacter(localPlayer)
        if not char or not hrp or not humanoid then return end
        moving = true

        coroutine.wrap(function()
            while moving do
                local tries = 0
                local candidatePos
                repeat
                    local dir = Vector3.new(math.random()*2-1, math.random()*0.4-0.2, math.random()*2-1).Unit
                    local dist = math.random(50, 140)
                    candidatePos = hrp.Position + dir * dist
                    local nearbyDanger = checkDangerNearby(candidatePos, safeDistance)
                    local alreadyExplored = isExplored(candidatePos)
                    tries = tries + 1
                    if tries > 50 then candidatePos = nil break end
                until not nearbyDanger and not alreadyExplored

                if candidatePos then
                    ultraLidarNavigate(hrp, humanoid, candidatePos)
                    markExplored(candidatePos)
                end

                if math.random() < 0.2 then
                    task.wait(0.5 + math.random())
                end

                task.wait(0.5)
            end
        end)()
    end
}

-- Остальные команды (lidartap, lidarfollow, lidarchase, parkourmode, lidarshow, lidarstop) используйте из предыдущей версии напрямую.

return Plugin

-- Изменения и улучшения:
-- 1. Вернул метод генерации лучей с точками на сфере, равномерно распределёнными по θ и φ, для максимально полного сканирования окружения.
-- 2. Добавил реальное использование этих точек (scanPoints) для выбора безопасного оптимального пути, эвристика учитывает направления, расстояния и избегает топтания.
-- 3. Переписал механизм прыжка (enhancedJump), используя более реалистичные проверки препятствий впереди и навеса, чтобы прыгать действительно при необходимости.
-- 4. Добавлено обучение карты в lidarrandom: бот запоминает, где уже был (с точностью до 0.1 позиции), и расширяет территорию патрулируя новые зоны.
-- 5. Переработан обход препятствий и других опасностей с использованием raycast проверок и смещением путей в альтернативные свободные направления при необходимости.
-- 6. Общая оптимизация задержек, параметров и логики движения.

Цитаты:
[1] IMG_20250817_025546_903.jpg https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/88450565/70f7488d-985e-4f24-8d05-d826d1a3bba2/IMG_20250817_025546_903.jpg
