ÐŸÐ¾Ð½ÑÐ» Ñ‚ÐµÐ±Ñ Ð½Ð° ðŸ’¯ â€” ÑÐµÐ¹Ñ‡Ð°Ñ Ñ‚Ð²Ð¾Ð¹ Ð±Ð¾Ñ‚ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð½Ðµ Ð´Ð¾Ð²Ð¾Ð´Ð¸Ñ‚ Ð»Ð¾Ð³Ð¸ÐºÑƒ Ð´Ð¾ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°, Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾:  
1. `computePath` + `followPath` Ð¾Ñ‚Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÑŽÑ‚ **Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð·**, Ð¸ Ð¿ÑƒÑ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð½Ðµ Ð¿ÐµÑ€ÐµÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ÑÑ Ð² Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ (Ð¾Ñ‚ÑÑŽÐ´Ð° Ð¾Ð½ Â«Ð¸Ð´Ñ‘Ñ‚ Ñ‚ÑƒÐ´Ð°-ÑÑŽÐ´Ð°Â»).  
2. **SmartFollow** ÑÐµÐ¹Ñ‡Ð°Ñ Ð·Ð°Ð¿ÑƒÑÐºÐ°ÐµÑ‚ÑÑ Ñ `RunService.Heartbeat`, Ð½Ð¾ Ð¿Ð¾ÑÐ»Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÐ¸ **Ð¿ÐµÑ€ÐµÑÑ‡Ñ‘Ñ‚ Ð¿ÑƒÑ‚Ð¸ Ð±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÐµÑ‚ÑÑ**, Ð° Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ Ð½ÐµÑ‚, ÐµÑÐ»Ð¸ Ð¿Ñ€ÐµÐ¿ÑÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð¼ÐµÑˆÐ°ÐµÑ‚.  
3. **SmartParkour** Ñ‚Ñ‹ Ñ…Ð¾Ñ‚ÐµÐ» Ð½Ðµ ÐºÐ°Ðº Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½ÑƒÑŽ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ, Ð° ÐºÐ°Ðº **Ð½Ð°Ð´ÑÑ‚Ñ€Ð¾Ð¹ÐºÑƒ**, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ *Ð¼Ð¾Ð´Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€ÑƒÐµÑ‚ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ð²ÑÐµÑ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹*.  
4. Ð”Ð»Ñ Ð¿Ñ€ÐµÐ´ÑÐºÐ°Ð·Ð°Ð½Ð¸Ñ Ð¸ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð° Ð»ÑƒÑ‡ÑˆÐµ Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ **Ñ„Ð»Ð°Ð³ Ñ€ÐµÐ¶Ð¸Ð¼Ð°** Ð¸ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ `followPath` / `toggleSmartTap` / `smartFollow` ÑƒÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ñ‚ÑŒ ÑÑ‚Ð¾Ñ‚ Ñ„Ð»Ð°Ð³.  

ðŸ’¡ Ð¯ Ð¿ÐµÑ€ÐµÐ¿Ð¸ÑˆÑƒ Ð²ÑÑ‘ Ñ‚Ð°Ðº, Ñ‡Ñ‚Ð¾Ð±Ñ‹:  
- Ð’ÑÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ (`smarttap`, `smartfollow`, `smartpath`) **Ð¿Ð¾ Ð´ÐµÑ„Ð¾Ð»Ñ‚Ñƒ Ñ…Ð¾Ð´Ð¸Ð»Ð¸ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Pathfinding**.  
- Ð•ÑÐ»Ð¸ Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ `;toggleparkour`, Ð¾Ð½Ð¸ Ð½Ð°Ñ‡Ð¸Ð½Ð°ÑŽÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ **Ð¿Ð°Ñ€ÐºÑƒÑ€Ð½ÑƒÑŽ Ð»Ð¾Ð³Ð¸ÐºÑƒ**: Ð¿Ñ€Ñ‹Ð¶ÐºÐ¸, Ð»Ð°Ð·Ð°Ð½Ð¸Ðµ, walljump, ÑÐ¾ÐºÑ€Ð°Ñ‰ÐµÐ½Ð¸Ñ ÑƒÐ³Ð»Ð¾Ð².  
- `smartfollow` Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð±ÐµÐ¶Ð¸Ñ‚ **Ð¿Ð¾ÑÑ‚Ð¾ÑÐ½Ð½Ð¾** Ñ Ð¿ÐµÑ€ÐµÑÑ‡Ñ‘Ñ‚Ð¾Ð¼ Ð¿ÑƒÑ‚Ð¸ ÐºÐ°Ð¶Ð´Ñ‹Ðµ 0.3â€“0.5 ÑÐµÐºÑƒÐ½Ð´Ñ‹ Ð¸ Ñ Ð¿Ñ€ÐµÐ´ÑÐºÐ°Ð·Ð°Ð½Ð¸ÐµÐ¼.  
- `smarttap` Ð±ÑƒÐ´ÐµÑ‚ Ð´Ð°Ð¶Ðµ Ð½Ð° ÐºÐ»Ð¸ÐºÐµ Ð¿Ñ€Ð¾Ð»Ð°Ð³Ð°Ñ‚ÑŒ Ð¿Ñ€ÐµÐ¿ÑÑ‚ÑÑ‚Ð²Ð¸Ñ Ñ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð¾Ð¼.  

---

### ðŸ“¦ ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¿Ð»Ð°Ð³Ð¸Ð½ Ñ Ñ€ÐµÐ¶Ð¸Ð¼Ð¾Ð¼ Parkour ÐºÐ°Ðº Ñ„Ð»Ð°Ð³Ð¾Ð¼  
```lua
-- SuperSmartPathfinder v2 (Ñ Parkour Mode)
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local smartTapEnabled = false
local parkourMode = false -- Ñ„Ð»Ð°Ð³ Ð´Ð»Ñ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð°
local moveConnection = nil
local followConnection = nil
local currentTarget = nil

--------------------------------------------
-- ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð°
--------------------------------------------
local function getCharacter(player)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character,
               player.Character:FindFirstChild("HumanoidRootPart"),
               player.Character:FindFirstChild("Humanoid")
    end
end

--------------------------------------------
-- Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¿ÑƒÑ‚Ð¸
--------------------------------------------
local function drawPath(waypoints)
    for i = 1, #waypoints - 1 do
        local p1, p2 = waypoints[i].Position, waypoints[i+1].Position
        local part = Instance.new("Part")
        part.Anchored, part.CanCollide = true, false
        part.Material, part.Color = Enum.Material.Neon, Color3.fromRGB(0, 255, 0)
        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Parent = workspace
        Debris:AddItem(part, 0.4)
    end
end

--------------------------------------------
-- PathFinder
--------------------------------------------
local function computePath(startPos, destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 3
    })
    path:ComputeAsync(startPos, destination)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        drawPath(waypoints)
        return waypoints
    end
end

--------------------------------------------
-- Parkour Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ
--------------------------------------------
local function performParkourMove(humanoid, hrp, obstacle)
    if not obstacle or not obstacle:IsA("BasePart") then return end
    local posDiff = obstacle.Position.Y - hrp.Position.Y

    -- ÐœÐ°Ð»Ñ‹Ð¹ ÑƒÑÑ‚ÑƒÐ¿ - Ð¿Ð¾Ð´Ñ‚ÑÐ¶ÐºÐ°
    if posDiff > 2 and posDiff < 6 then
        humanoid.Jump = true
        task.wait(0.15)
        hrp.CFrame = hrp.CFrame * CFrame.new(0, posDiff + 2, 0)
    end
    -- Ð’Ñ‹ÑÐ¾ÐºÐ°Ñ ÑÑ‚ÐµÐ½Ð° - walljump
    if posDiff >= 6 and posDiff <= 8 then
        humanoid.Jump = true
        task.wait(0.15)
        humanoid:Move(Vector3.new(0,0,-1))
        task.wait(0.1)
        humanoid.Jump = true
    end
    -- Ð”Ð¸Ð°Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ñ‹Ð¶Ð¾Ðº
    if posDiff > 8 and posDiff < 12 then
        humanoid.Jump = true
        task.wait(0.1)
        hrp.CFrame = hrp.CFrame * CFrame.new(1.5, 3, 1.5)
    end
end

--------------------------------------------
-- Ð¡Ð»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾ Ð¿ÑƒÑ‚Ð¸ (ÑƒÑ‡Ñ‘Ñ‚ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð°)
--------------------------------------------
local function followPath(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()

        if parkourMode and not reached then
            local ray = workspace:Raycast(hrp.Position,
                (waypoint.Position - hrp.Position).Unit * 3,
                RaycastParams.new())
            if ray and ray.Instance then
                performParkourMove(humanoid, hrp, ray.Instance)
            end
        end

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
    end
    moving = false
end

--------------------------------------------
-- SMARTTAP Toggle
--------------------------------------------
local function toggleSmartTap()
    smartTapEnabled = not smartTapEnabled
    if smartTapEnabled then
        print("[ðŸ§  SMARTTAP] Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½")
        moveConnection = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mouse = localPlayer:GetMouse()
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    local path = computePath(hrp.Position, mouse.Hit.Position)
                    if path then followPath(humanoid, hrp, path) end
                end
            end
        end)
    else
        print("[ðŸ›‘ SMARTTAP] Ð’Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½")
        if moveConnection then moveConnection:Disconnect() end
    end
end

--------------------------------------------
-- SMARTFOLLOW
--------------------------------------------
local function smartFollow(targetFilter)
    if followConnection then followConnection:Disconnect() end
    local targets = _G.getPlayer(targetFilter)
    if #targets == 0 then
        warn("[âš  SMARTFOLLOW] Ð˜Ð³Ñ€Ð¾Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.")
        return
    end
    currentTarget = targets[1]
    print("[ðŸ§  SMARTFOLLOW] Ð¡Ð»ÐµÐ´ÑƒÑŽ Ð·Ð°", currentTarget.Name)

    followConnection = RunService.Heartbeat:Connect(function()
        if not moving and currentTarget then
            local char, hrp, humanoid = getCharacter(localPlayer)
            local targetChar, targetHRP = getCharacter(currentTarget)
            if hrp and humanoid and targetHRP then
                local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.4)
                local path = computePath(hrp.Position, predictedPos)
                if path then followPath(humanoid, hrp, path) end
            end
        end
    end)
end

--------------------------------------------
-- SMARTPATH
--------------------------------------------
local function smartPathXYZ(args)
    if #args < 3 then warn("Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ: smartpath X Y Z") return end
    local char, hrp, humanoid = getCharacter(localPlayer)
    local x,y,z = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
    if x and y and z and hrp and humanoid then
        local path = computePath(hrp.Position, Vector3.new(x,y,z))
        if path then followPath(humanoid, hrp, path) end
    end
end

--------------------------------------------
-- STOPMOVE
--------------------------------------------
local function stopMoving()
    moving = false
    if followConnection then followConnection:Disconnect() end
    local _, _, humanoid = getCharacter(localPlayer)
    if humanoid then humanoid:Move(Vector3.new()) end
    print("[ðŸ›‘ STOPMOVE] ÐžÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾.")
end

--------------------------------------------
-- TOGGLE PARKOUR MODE
--------------------------------------------
local function toggleParkour()
    parkourMode = not parkourMode
    print(parkourMode and "[ðŸ¤¸ PARKOUR MODE] Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½" or "[ðŸ¤¸ PARKOUR MODE] Ð’Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½")
end

--------------------------------------------
-- ÐŸÐ»Ð°Ð³Ð¸Ð½
--------------------------------------------
local Plugin = {
    ["PluginName"] = "SuperSmartPathfinder",
    ["PluginDescription"] = "Baritone-style Ð¿Ð°Ñ‚Ñ„Ð°Ð¹Ð½Ð´ÐµÑ€ + Parkour Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€",
    ["Commands"] = {
        ["smarttap"] = {["Function"] = function(a,s) toggleSmartTap() end},
        ["smartfollow"] = {["Function"] = function(a,s) smartFollow(a[1] or "nearest") end},
        ["smartpath"] = {["Function"] = function(a,s) smartPathXYZ(a) end},
        ["stopmove"] = {["Function"] = function(a,s) stopMoving() end},
        ["toggleparkour"] = {["Function"] = function(a,s) toggleParkour() end}
    }
}

return Plugin
```

---

### âœ… Ð§Ñ‚Ð¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¾ÑÑŒ:
- **`toggleparkour`** â€” Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚/Ð²Ñ‹ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð° Ð´Ð»Ñ *Ð²ÑÐµÑ…* Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹.  
- Ð¢ÐµÐ¿ÐµÑ€ÑŒ **smartfollow** Ð¸ **smarttap** Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾, Ð¿Ð¾ÑÑ‚Ð¾ÑÐ½Ð½Ð¾ Ð¿ÐµÑ€ÐµÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ñ Ð¿ÑƒÑ‚ÑŒ.  
- ÐŸÑ€Ð¸ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½Ð½Ð¾Ð¼ Ð¿Ð°Ñ€ÐºÑƒÑ€Ðµ Ð±Ð¾Ñ‚ Ð»Ð°Ð·Ð¸Ñ‚/Ð¿Ñ€Ñ‹Ð³Ð°ÐµÑ‚, Ð¿Ñ€Ð¸ Ð²Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ð¾Ð¼ â€” Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¾Ð±Ñ…Ð¾Ð´Ð¸Ñ‚ Ð¿Ð¾ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ð¼Ñƒ pathfinding.  
- Ð’ÑÐµ Ð»Ð¸ÑˆÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð½Ñ‹Ðµ ÐºÐ¾Ð¿Ð¸Ð¸ ÑƒÐ±Ñ€Ð°Ð½Ñ‹ â€” Ð¿Ñ€Ð¾Ñ‰Ðµ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ.  

---

ðŸ’¡ Ð•ÑÐ»Ð¸ Ñ…Ð¾Ñ‡ÐµÑˆÑŒ, Ñ Ð¼Ð¾Ð³Ñƒ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ **"Ñ€ÐµÐ¶Ð¸Ð¼ ÑÑ€Ð¾ÑÑ‚Ð¸"** Ð² smartfollow, Ð³Ð´Ðµ Ð¾Ð½ Ð±ÑƒÐ´ÐµÑ‚ Ð³Ð½Ð°Ñ‚ÑŒ Ñ†ÐµÐ»ÑŒ Ñ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð¾Ð¼, ÑÐ¾ÐºÑ€Ð°Ñ‰Ð°Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾ ÑƒÐ³Ð»Ñ‹ Ð¸ Ð²Ñ€ÐµÐ·Ð°ÑÑÑŒ Ð² Ð½ÐµÑ‘.  
Ð¥Ð¾Ñ‡ÐµÑˆÑŒ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ñ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð» **Aggressive Chase Mode** Ð² ÑÑ‚Ñƒ ÑÐ¸ÑÑ‚ÐµÐ¼Ñƒ?