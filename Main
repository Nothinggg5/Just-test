Ооо, брат, я тебя понял 🔥💡  
Ты хочешь, чтобы **SmartParkour** был не просто отдельной командой по координатам, а **глобальным режимом** — т.е. ты его включаешь (toggle), и все функции **smarttap**, **smartfollow**, **smartpath** сразу начинают работать с режимом “паркура” 🤸‍♂️, переосмысливая маршрут.  

Короче, это будет **переключатель “Паркур-режима”**:  
- Если **Parkour Mode OFF** → всё работает обычным путём (PathfindingService без трюков).  
- Если **Parkour Mode ON** → все алгоритмы перемещения используют:
  - **Walljump**  
  - **Edge Grab & Climb**  
  - **Diagonal Jump Trick**  
  - **Corner Cut** и адаптацию к узким проходам  

По сути, этот модуль будет **надстройкой** над движением, которая перехватывает вызовы `followPath()` и заменяет их на `followPathWithParkour()`.

---

## 📜 Обновлённый полный плагин с ParkourToggle
```lua
-- SuperSmartPathfinder with Parkour Toggle Mode
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local smartTapEnabled = false
local parkourMode = false -- 🎯 Toggle Parkour Mode
local moveConnection = nil
local followConnection = nil
local currentTarget = nil

--------------------------------------------------------
-- Вспомогательные функции
--------------------------------------------------------
local function getCharacter(player)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character,
               player.Character:FindFirstChild("HumanoidRootPart"),
               player.Character:FindFirstChild("Humanoid")
    end
    return nil
end

-- Визуализация пути
local function drawPath(waypoints)
    for i = 1, #waypoints - 1 do
        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.CanCollide = false
        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Parent = workspace
        Debris:AddItem(part, 0.5)
    end
end

-- Построение пути
local function computePath(startPos, destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 3,
        Costs = {
            Water = math.huge
        }
    })
    path:ComputeAsync(startPos, destination)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        drawPath(waypoints)
        return waypoints
    end
    return nil
end

--------------------------------------------------------
-- Паркур
--------------------------------------------------------
local function performParkourMove(humanoid, hrp, obstacle)
    if obstacle and obstacle:IsA("BasePart") then
        local posDiff = obstacle.Position.Y - hrp.Position.Y

        -- Edge Grab climb
        if posDiff > 2 and posDiff < 6 then
            humanoid.Jump = true
            task.wait(0.2)
            hrp.CFrame = hrp.CFrame * CFrame.new(0, posDiff + 2, 0)
        end

        -- WallJump
        if posDiff >= 6 and posDiff <= 8 then
            humanoid.Jump = true
            task.wait(0.15)
            humanoid:Move(Vector3.new(0, 0, -1))
            task.wait(0.1)
            humanoid.Jump = true
        end

        -- Diagonal jump trick
        if posDiff > 8 and posDiff < 12 then
            humanoid.Jump = true
            task.wait(0.1)
            hrp.CFrame = hrp.CFrame * CFrame.new(1.5, 3, 1.5)
        end
    end
end

-- Следование по пути с паркуром
local function followPathWithParkour(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()

        if not reached then
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {workspace.Terrain, hrp.Parent}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local ray = workspace:Raycast(hrp.Position, (waypoint.Position - hrp.Position).Unit * 3, params)

            if ray then
                performParkourMove(humanoid, hrp, ray.Instance)
            end
        end

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
    end
    moving = false
end

--------------------------------------------------------
-- Функции движения с условием Parkour Mode
--------------------------------------------------------
local function followPath(humanoid, hrp, waypoints)
    if parkourMode then
        followPathWithParkour(humanoid, hrp, waypoints)
    else
        moving = true
        for _, waypoint in ipairs(waypoints) do
            if not moving then break end
            humanoid:MoveTo(waypoint.Position)
            local reached = humanoid.MoveToFinished:Wait()
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                humanoid.Jump = true
            end
            if not reached then
                break
            end
        end
        moving = false
    end
end

--------------------------------------------------------
-- Команды
--------------------------------------------------------
-- SMARTTAP
local function toggleSmartTap()
    smartTapEnabled = not smartTapEnabled
    if smartTapEnabled then
        print("[🧠 SMARTTAP] Включен, кликайте по карте!")
        moveConnection = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mouse = localPlayer:GetMouse()
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    local path = computePath(hrp.Position, Vector3.new(mouse.Hit.X, mouse.Hit.Y, mouse.Hit.Z))
                    if path then followPath(humanoid, hrp, path) end
                end
            end
        end)
    else
        print("[🛑 SMARTTAP] Выключен.")
        if moveConnection then moveConnection:Disconnect() end
    end
end

-- SMARTFOLLOW
local function smartFollow(targetFilter)
    if followConnection then followConnection:Disconnect() end
    local targetPlayers = _G.getPlayer(targetFilter)
    if #targetPlayers == 0 then
        warn("[⚠ SMARTFOLLOW] Игрок не найден.")
        return
    end
    currentTarget = targetPlayers[1]
    print("[🧠 SMARTFOLLOW] Следование за:", currentTarget.Name, parkourMode and "(Паркур)" or "")

    followConnection = RunService.Heartbeat:Connect(function()
        if not moving and currentTarget then
            local char, hrp, humanoid = getCharacter(localPlayer)
            local targetChar, targetHRP = getCharacter(currentTarget)
            if char and hrp and humanoid and targetChar and targetHRP then
                local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.5)
                local path = computePath(hrp.Position, predictedPos)
                if path then followPath(humanoid, hrp, path) end
            end
        end
    end)
end

-- SMARTPATH
local function smartPathXYZ(args)
    if #args < 3 then
        warn("Использование: smartpath X Y Z")
        return
    end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if char and hrp and humanoid then
        local x, y, z = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
        if x and y and z then
            local goal = Vector3.new(x, y, z)
            local path = computePath(hrp.Position, goal)
            if path then followPath(humanoid, hrp, path) end
        end
    end
end

-- TOGGLE PARKOUR MODE
local function toggleParkour()
    parkourMode = not parkourMode
    print(parkourMode and "[🤸‍♂️ PARKOUR MODE] ВКЛЮЧЕН: все движения будут с паркуром"
                        or "[🚶 PARKOUR MODE] ВЫКЛЮЧЕН: стандартное поведение Pathfinding")
end

-- STOPMOVE
local function stopMoving()
    moving = false
    if followConnection then followConnection:Disconnect() end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if humanoid then
        humanoid:Move(Vector3.new())
    end
    print("[🛑 STOPMOVE] Все движения остановлены!")
end

--------------------------------------------------------
-- Плагин Infinite Yield
--------------------------------------------------------
local Plugin = {
    ["PluginName"] = "SuperSmartPathfinder",
    ["PluginDescription"] = "Baritone-уровень Pathfinding с toggle Паркуром для Roblox",
    ["Commands"] = {
        ["smarttap"] = {
            ["ListName"] = "smarttap",
            ["Description"] = "Вкл/Выкл умный Tap-to-Move",
            ["Function"] = function(args, speaker)
                toggleSmartTap()
            end
        },
        ["smartfollow"] = {
            ["ListName"] = "smartfollow",
            ["Description"] = "Следовать за игроком с предсказанием движения",
            ["Function"] = function(args, speaker)
                smartFollow(args[1] or "nearest")
            end
        },
        ["smartpath"] = {
            ["ListName"] = "smartpath",
            ["Description"] = "Построить путь к координатам",
            ["Function"] = function(args, speaker)
                smartPathXYZ(args)
            end
        },
        ["parkourmode"] = {
            ["ListName"] = "parkourmode",
            ["Description"] = "Вкл/Выкл глобальный паркур-режим для всех функций",
            ["Function"] = function(args, speaker)
                toggleParkour()
            end
        },
        ["stopmove"] = {
            ["ListName"] = "stopmove",
            ["Description"] = "Остановить любое движение",
            ["Function"] = function(args, speaker)
                stopMoving()
            end
        }
    }
}

return Plugin
```

---

💎 Теперь **parkourmode** — это глобальный тумблер. Включишь — **smarttap, smartfollow, smartpath** сразу начинают использовать паркур-алгоритм вместо обычного движения.

---

🔥 Если хочешь, я могу ещё имплементировать **автоматическое распознавание режима**:  
бот сам включает паркур, когда понимает, что путь сложный, и выключает, если идёт по ровной дороге.  
Хочешь, чтобы я сделал такую **автоматическую адаптацию паркура**?