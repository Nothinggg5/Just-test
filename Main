local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Plugin = {
    ["PluginName"] = "SmartNavigator",
    ["PluginDescription"] = "Умный tap-to-move, следование и построение пути с визуализацией и стоп-краном",
    ["Commands"] = {}
}

local smartTapEnabled = false
local currentMoveConnection = nil
local currentFollowTask = nil
local currentPathTask = nil

-- Вспомогательная функция для отрисовки линий пути
local function drawDebugPath(points)
    for i = 1, #points - 1 do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.BrickColor = BrickColor.new("Bright yellow")
        local pos1 = points[i]
        local pos2 = points[i + 1]
        local dist = (pos2 - pos1).Magnitude
        part.Size = Vector3.new(0.2, 0.2, dist)
        part.CFrame = CFrame.new((pos1 + pos2) / 2, pos1) * CFrame.Angles(0, math.rad(90), 0)
        part.Parent = workspace
        game.Debris:AddItem(part, 3)
    end
end

-- Останавливает все текущие действия и движения
local function cancelCurrentTasks()
    if currentMoveConnection then
        currentMoveConnection:Disconnect()
        currentMoveConnection = nil
    end
    currentFollowTask = nil
    currentPathTask = nil

    local player = Players.LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        humanoid:MoveTo(player.Character.HumanoidRootPart.Position)
        humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end
end

-- smarttap (переключатель)
Plugin.Commands["smarttap"] = {
    ["ListName"] = "smarttap",
    ["Description"] = "Включить/выключить умный tap-to-move (нажмите мышь, чтобы идти)",
    ["Aliases"] = {},
    ["Function"] = function(args, speaker)
        smartTapEnabled = not smartTapEnabled
        local player = Players.LocalPlayer
        local mouse = player:GetMouse()

        if smartTapEnabled then
            if currentMoveConnection then currentMoveConnection:Disconnect() end
            currentMoveConnection = mouse.Button1Down:Connect(function()
                if not smartTapEnabled then return end
                local char = player.Character
                if not char or not char.PrimaryPart then return end
                cancelCurrentTasks()
                local targetPos = mouse.Hit.p
                local path = PathfindingService:CreatePath({
                    AgentRadius = 2,
                    AgentHeight = 5,
                    AgentCanJump = false,
                    AgentCanClimb = true
                })
                path:ComputeAsync(char.PrimaryPart.Position, targetPos)
                if path.Status == Enum.PathStatus.Success then
                    local waypoints = path:GetWaypoints()
                    local points = {}
                    for i, wp in ipairs(waypoints) do
                        points[i] = wp.Position
                    end
                    drawDebugPath(points)
                    for _, wp in ipairs(waypoints) do
                        humanoid = char:FindFirstChild("Humanoid")
                        if not humanoid then break end
                        humanoid:MoveTo(wp.Position)
                        if not humanoid.MoveToFinished:Wait() then break end
                    end
                end
            end)
            print("SmartTap включён")
        else
            if currentMoveConnection then
                currentMoveConnection:Disconnect()
                currentMoveConnection = nil
            end
            cancelCurrentTasks()
            print("SmartTap выключен")
        end
    end
}

-- smartpath команда на основе координат
Plugin.Commands["smartpath"] = {
    ["ListName"] = "smartpath",
    ["Description"] = "Построить и пройти путь к координатам: smartpath x y z",
    ["Aliases"] = {},
    ["Function"] = function(args, speaker)
        local player = Players.LocalPlayer
        if not player.Character or not player.Character.PrimaryPart then return end
        local x, y, z = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
        if not (x and y and z) then return end
        cancelCurrentTasks()

        currentPathTask = task.spawn(function()
            local startPos = player.Character.PrimaryPart.Position
            local targetPos = Vector3.new(x, y, z)
            local path = PathfindingService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = false,
                AgentCanClimb = true
            })
            path:ComputeAsync(startPos, targetPos)
            if path.Status == Enum.PathStatus.Success then
                local wps = path:GetWaypoints()
                local points = {}
                for i, wp in ipairs(wps) do
                    points[i] = wp.Position
                end
                drawDebugPath(points)
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if not humanoid then return end
                for _, wp in ipairs(wps) do
                    humanoid:MoveTo(wp.Position)
                    if not humanoid.MoveToFinished:Wait() then break end
                end
            else
                warn("Путь не может быть построен")
            end
        end)
    end
}

-- smartfollow команда для следования по селектору
Plugin.Commands["smartfollow"] = {
    ["ListName"] = "smartfollow",
    ["Description"] = "Следовать за игроком или группой: smartfollow <селектор>",
    ["Aliases"] = {},
    ["Function"] = function(args, speaker)
        local player = Players.LocalPlayer
        if not player.Character or not player.Character.PrimaryPart then return end
        local selector = args[1]
        if not selector then return end
        cancelCurrentTasks()

        local function resolveTargets(sel)
            sel = sel:lower()
            local targets = {}

            if sel == "me" then
                table.insert(targets, player)
            elseif sel == "all" then
                targets = Players:GetPlayers()
            elseif sel == "others" then
                for _, p in pairs(Players:GetPlayers()) do
                    if p ~= player then table.insert(targets, p) end
                end
            elseif sel == "random" then
                local plrs = Players:GetPlayers()
                if #plrs > 0 then
                    table.insert(targets, plrs[math.random(1, #plrs)])
                end
            elseif sel:sub(1,1) == "@" then
                local name = sel:sub(2)
                for _, p in pairs(Players:GetPlayers()) do
                    if p.Name:lower() == name then
                        table.insert(targets, p)
                        break
                    end
                end
            else
                -- Поиск по команде или имени команды
                for _, p in pairs(Players:GetPlayers()) do
                    if p.Team and p.Team.Name:lower() == sel then
                        table.insert(targets, p)
                    end
                end
            end
            return targets
        end

        currentFollowTask = task.spawn(function()
            while true do
                local targets = resolveTargets(selector)
                if #targets == 0 then break end
                local target = targets[1]
                if not target.Character or not target.Character.PrimaryPart then break end

                local startPos = player.Character.PrimaryPart.Position
                local goalPos = target.Character.PrimaryPart.Position

                local path = PathfindingService:CreatePath({
                    AgentRadius = 2,
                    AgentHeight = 5,
                    AgentCanJump = false,
                    AgentCanClimb = true
                })

                path:ComputeAsync(startPos, goalPos)
                if path.Status == Enum.PathStatus.Success then
                    local waypoints = path:GetWaypoints()
                    local points = {}
                    for i, wp in ipairs(waypoints) do
                        points[i] = wp.Position
                    end
                    drawDebugPath(points)
                    local humanoid = player.Character:FindFirstChild("Humanoid")
                    if not humanoid then break end
                    for _, wp in ipairs(waypoints) do
                        humanoid:MoveTo(wp.Position)
                        if not humanoid.MoveToFinished:Wait() then break end
                    end
                else
                    warn("Путь для следования не построен")
                end
                task.wait(0.5)
            end
        end)
    end
}

return Plugin
