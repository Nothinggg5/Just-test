ÐŸÑ€Ð¸Ð½Ð¾ÑˆÑƒ Ð¸Ð·Ð²Ð¸Ð½ÐµÐ½Ð¸Ñ Ð·Ð° Ð½ÐµÐ´Ð¾Ñ€Ð°Ð·ÑƒÐ¼ÐµÐ½Ð¸Ðµ. Ð”Ð°Ð²Ð°Ð¹Ñ‚Ðµ Ð½Ð°Ð¿Ð¸ÑˆÐµÐ¼ ÑÐºÑ€Ð¸Ð¿Ñ‚ Ñ Ð½ÑƒÐ»Ñ, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð±ÑƒÐ´ÐµÑ‚ Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ‚ÑŒ Ð² ÑÐµÐ±Ñ Ð²ÑÐµ Ñ‚Ñ€ÐµÐ±ÑƒÐµÐ¼Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸, Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð°Ñ‚ÐµÐ»ÑŒ Ñ€ÐµÐ¶Ð¸Ð¼Ð° Ð¿Ð°Ñ€ÐºÑƒÑ€Ð°. Ð’Ð¾Ñ‚ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ð¹ ÑÐºÑ€Ð¸Ð¿Ñ‚:

```lua
-- SuperSmartPathfinder with Parkour Toggle Mode
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local smartTapEnabled = false
local parkourMode = false -- ðŸŽ¯ Toggle Parkour Mode
local moveConnection = nil
local followConnection = nil
local currentTarget = nil

--------------------------------------------------------
-- Ð’ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
--------------------------------------------------------
local function getCharacter(player)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character,
               player.Character:FindFirstChild("HumanoidRootPart"),
               player.Character:FindFirstChild("Humanoid")
    end
    return nil, nil, nil
end

-- Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¿ÑƒÑ‚Ð¸
local function drawPath(waypoints)
    for i = 1, #waypoints - 1 do
        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.CanCollide = false
        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Parent = workspace
        Debris:AddItem(part, 0.5)
    end
end

-- ÐŸÐ¾ÑÑ‚Ñ€Ð¾ÐµÐ½Ð¸Ðµ Ð¿ÑƒÑ‚Ð¸
local function computePath(startPos, destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 3,
        Costs = {
            Water = math.huge
        }
    })
    path:ComputeAsync(startPos, destination)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        drawPath(waypoints)
        return waypoints
    end
    return nil
end

--------------------------------------------------------
-- ÐŸÐ°Ñ€ÐºÑƒÑ€
--------------------------------------------------------
local function performParkourMove(humanoid, hrp, obstacle)
    if obstacle and obstacle:IsA("BasePart") then
        local posDiff = obstacle.Position.Y - hrp.Position.Y

        -- Edge Grab climb
        if posDiff > 2 and posDiff < 6 then
            humanoid.Jump = true
            task.wait(0.2)
            hrp.CFrame = hrp.CFrame * CFrame.new(0, posDiff + 2, 0)
        end

        -- WallJump
        if posDiff >= 6 and posDiff <= 8 then
            humanoid.Jump = true
            task.wait(0.15)
            humanoid:Move(Vector3.new(0, 0, -1))
            task.wait(0.1)
            humanoid.Jump = true
        end

        -- Diagonal jump trick
        if posDiff > 8 and posDiff < 12 then
            humanoid.Jump = true
            task.wait(0.1)
            hrp.CFrame = hrp.CFrame * CFrame.new(1.5, 3, 1.5)
        end

        -- Corner Cut
        if posDiff >= 0 and posDiff <= 2 then
            humanoid:Move(Vector3.new(1, 0, 1))
        end
    end
end

-- Ð¡Ð»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾ Ð¿ÑƒÑ‚Ð¸ Ñ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð¾Ð¼
local function followPathWithParkour(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()

        if not reached then
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {workspace.Terrain, hrp.Parent}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local ray = workspace:Raycast(hrp.Position, (waypoint.Position - hrp.Position).Unit * 3, params)

            if ray then
                performParkourMove(humanoid, hrp, ray.Instance)
            end
        end

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
    end
    moving = false
end

-- ÐžÐ±Ñ‹Ñ‡Ð½Ð¾Ðµ ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾ Ð¿ÑƒÑ‚Ð¸
local function followPathNormal(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        humanoid.MoveToFinished:Wait()
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
    end
    moving = false
end

-- Ð’Ñ‹Ð±Ð¾Ñ€ Ñ€ÐµÐ¶Ð¸Ð¼Ð° Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ
local function followPath(humanoid, hrp, waypoints)
    if parkourMode then
        followPathWithParkour(humanoid, hrp, waypoints)
    else
        followPathNormal(humanoid, hrp, waypoints)
    end
end

--------------------------------------------------------
-- ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹
--------------------------------------------------------
-- SMARTTAP
local function toggleSmartTap()
    smartTapEnabled = not smartTapEnabled
    if smartTapEnabled then
        print("[ðŸ§  SMARTTAP] Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½, ÐºÐ»Ð¸ÐºÐ°Ð¹Ñ‚Ðµ Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ðµ!")
        moveConnection = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mouse = localPlayer:GetMouse()
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    local path = computePath(hrp.Position, mouse.Hit.Position)
                    if path then followPath(humanoid, hrp, path) end
                end
            end
        end)
    else
        print("[ðŸ›‘ SMARTTAP] Ð’Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½.")
        if moveConnection then moveConnection:Disconnect() end
    end
end

-- SMARTFOLLOW
local function smartFollow(targetFilter)
    if followConnection then followConnection:Disconnect() end
    local targetPlayers = _G.getPlayer(targetFilter)
    if #targetPlayers == 0 then
        warn("[âš  SMARTFOLLOW] Ð˜Ð³Ñ€Ð¾Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.")
        return
    end
    currentTarget = targetPlayers[1]
    print("[ðŸ§  SMARTFOLLOW] Ð¡Ð»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð·Ð°:", currentTarget.Name, parkourMode and "(ÐŸÐ°Ñ€ÐºÑƒÑ€)" or "")

    followConnection = RunService.Heartbeat:Connect(function()
        if not moving and currentTarget then
            local char, hrp, humanoid = getCharacter(localPlayer)
            local targetChar, targetHRP = getCharacter(currentTarget)
            if char and hrp and humanoid and targetChar and targetHRP then
                local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.5)
                local path = computePath(hrp.Position, predictedPos)
                if path then followPath(humanoid, hrp, path) end
            end
        end
    end)
end

-- SMARTPATH
local function smartPathXYZ(args)
    if #args < 3 then
        warn("Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ: smartpath X Y Z")
        return
    end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if char and hrp and humanoid then
        local x, y, z = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
        if x and y and z then
            local goal = Vector3.new(x, y, z)
            local path = computePath(hrp.Position, goal)
            if path then followPath(humanoid, hrp, path) end
        end
    end
end

-- TOGGLE PARKOUR MODE
local function toggleParkour()
    parkourMode = not parkourMode
    print(parkourMode and "[ðŸ¤¸â€â™‚ï¸ PARKOUR MODE] Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½" or "[ðŸš¶â€â™‚ï¸ PARKOUR MODE] Ð’Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½")
end

-- STOPMOVE
local function stopMoving()
    moving = false
    if followConnection then followConnection:Disconnect() end
    local char, hrp, humanoid = getCharacter(localPlayer)
    if humanoid then
        humanoid:Move(Vector3.new())
    end
    print("[ðŸ›‘ STOPMOVE] Ð”Ð²Ð¸Ð¶ÐµÐ½Ð¸Ðµ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾.")
end

--------------------------------------------------------
-- ÐŸÐ»Ð°Ð³Ð¸Ð½ Infinite Yield
--------------------------------------------------------
local Plugin = {
    ["PluginName"] = "SuperSmartPathfinder",
    ["PluginDescription"] = "Baritone-ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Pathfinding Ñ toggle ÐŸÐ°Ñ€ÐºÑƒÑ€Ð¾Ð¼ Ð´Ð»Ñ Roblox",
    ["Commands"] = {
        ["smarttap"] = {
            ["ListName"] = "smarttap",
            ["Description"] = "Ð’ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚/Ð²Ñ‹ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ ÑƒÐ¼Ð½Ð¾Ðµ Tap-to-Move",
            ["Function"] = function(args, speaker)
                toggleSmartTap()
            end
        },
        ["smartfollow"] = {
            ["ListName"] = "smartfollow",
            ["Description"] = "Ð¡Ð»ÐµÐ´ÑƒÐµÑ‚ Ð·Ð° ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ñ‹Ð¼ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð¼",
            ["Function"] = function(args, speaker)
                smartFollow(args[1] or "nearest")
            end
        },
        ["smartpath"] = {
            ["ListName"] = "smartpath",
            ["Description"] = "ÐŸÐ¾ÑÑ‚Ñ€Ð¾ÐµÐ½Ð¸Ðµ Ð¿ÑƒÑ‚Ð¸ Ðº Ð·Ð°Ð´Ð°Ð½Ð½Ñ‹Ð¼ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð°Ð¼",
            ["Function"] = function(args, speaker)
                smartPathXYZ(args)
            end
        },
        ["parkourmode"] = {
            ["ListName"] = "parkourmode",
            ["Description"] = "ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¿Ð°Ñ€ÐºÑƒÑ€Ð°",
            ["Function"] = function(args, speaker)
                toggleParkour()
            end
        },
        ["stopmove"] = {
            ["ListName"] = "stopmove",
            ["Description"] = "ÐžÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ Ð»ÑŽÐ±Ð¾Ðµ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ðµ",
            ["Function"] = function(args, speaker)
                stopMoving()
            end
        }
    }
}

return Plugin
```

Ð­Ñ‚Ð¾Ñ‚ ÑÐºÑ€Ð¸Ð¿Ñ‚ Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ð²ÑÐµ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹, Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð°Ñ‚ÐµÐ»ÑŒ Ñ€ÐµÐ¶Ð¸Ð¼Ð° Ð¿Ð°Ñ€ÐºÑƒÑ€Ð° (`parkourmode`), ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð²Ð»Ð¸ÑÐµÑ‚ Ð½Ð° Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ `smarttap`, `smartfollow`, Ð¸ `smartpath`. Ð£Ð±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ `_G.getPlayer` ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð° Ð² Ð²Ð°ÑˆÐµÐ¼ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ð¸ Infinite Yield Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð¿Ð¾ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ñƒ Ð² ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ `smartfollow`. Ð•ÑÐ»Ð¸ Ñƒ Ð²Ð°Ñ Ð²Ð¾Ð·Ð½Ð¸ÐºÐ½ÑƒÑ‚ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ ÑÑ‚Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÐµÐ¹ Ð¸Ð»Ð¸ Ð´Ñ€ÑƒÐ³Ð¸Ð¼Ð¸ Ñ‡Ð°ÑÑ‚ÑÐ¼Ð¸ ÑÐºÑ€Ð¸Ð¿Ñ‚Ð°, Ð¿Ð¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, ÑƒÑ‚Ð¾Ñ‡Ð½Ð¸Ñ‚Ðµ.