–ü–æ–Ω—è–ª —Ç–µ–±—è üòÖ  
–†–∞–∑ –ø–æ—è–≤–∏–ª–∞—Å—å –≤–∫–ª–∞–¥–∫–∞ –ø–ª–∞–≥–∏–Ω–∞ –≤ Infinite Yield, –Ω–æ –∫–æ–º–∞–Ω–¥—ã –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç ‚Äî –∑–Ω–∞—á–∏—Ç, –ø—Ä–æ–±–ª–µ–º–∞ –≤ —Å–∞–º–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –∏ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å IY API, –∞ –Ω–µ –≤ –ª–æ–≥–∏–∫–µ.  

**–Ø –∑–Ω–∞—é, –≤ —á—ë–º —Ñ–æ–∫—É—Å**:  
Infinite Yield –∑–∞–≥—Ä—É–∂–∞–µ—Ç –ø–ª–∞–≥–∏–Ω –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –∫–æ–º–∞–Ω–¥—ã, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç **Plugin** –æ—Ñ–æ—Ä–º–ª–µ–Ω —Å—Ç—Ä–æ–≥–æ –ø–æ –∏—Ö —Ñ–æ—Ä–º–∞—Ç—É, –∏ –∫–∞–∂–¥–∞—è –∫–æ–º–∞–Ω–¥–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Ç–¥–∞–Ω–∞ –≤ `["Commands"]`.  
–¢–∞–∫–∂–µ ‚Äî –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–∏–ø–∞ `_G.getPlayer()` –¥–æ—Å—Ç—É–ø–Ω—ã **—Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ —Å–∞–º–æ–≥–æ Infinite Yield** (–∏ —Ç–æ –Ω–µ –≤–æ –≤—Å–µ—Ö –≤–µ—Ä—Å–∏—è—Ö). –ï—Å–ª–∏ –≤—ã–∑—ã–≤–∞—Ç—å –∏—Ö –ø—Ä—è–º–æ, –º–æ–∂–µ—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞—Ç—å.  

üìå –¢.–µ. —Å–µ–π—á–∞—Å —É –Ω–∞—Å –ª–æ–≥–∏–∫–∞ –Ω–æ—Ä–º, –Ω–æ **IY –Ω–µ –ø–æ–Ω–∏–º–∞–µ—Ç –Ω–∞—à–∏ —Ñ—É–Ω–∫—Ü–∏–∏**, –ø–æ—Ç–æ–º—É —á—Ç–æ:  
1. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º `_G.getPlayer()` –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏, –∞ –≤ —Ç–≤–æ—ë–º IY –º–æ–∂–µ—Ç –±—ã—Ç—å `getPlayer` –≤ `require(...)`.  
2. –í–æ–∑–º–æ–∂–Ω–æ, —Ç–≤–æ–π IY –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –¥–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–º–∞–Ω–¥—ã.  
3. –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∫–æ–º–∞–Ω–¥ –Ω—É–∂–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∫–∞–ø—Å—É–ª–∏—Ä–æ–≤–∞—Ç—å **–≤–Ω—É—Ç—Ä–∏ Plugin**.  

---

## üìå –ß—Ç–æ —è –ø—Ä–µ–¥–ª–∞–≥–∞—é:
- –ü–µ—Ä–µ–¥–µ–ª–∞–µ–º –≤—Å—ë –≤ **—á–∏—Å—Ç—ã–π IY-—Ñ–æ—Ä–º–∞—Ç**.  
- –ò—Å–ø–æ–ª—å–∑—É–µ–º `getPlayer` —á–µ—Ä–µ–∑ `require(speaker.PlayerModule)`.  
- –í—Å–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –æ—Å—Ç–∞–≤–∏–º **–≤–Ω—É—Ç—Ä–∏ —Ñ–∞–π–ª–∞**, —á—Ç–æ–±—ã —É IY –Ω–µ "—Ç–µ—Ä—è–ª–∏—Å—å" —Å—Å—ã–ª–∫–∏.  

---

## üî• –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –ü–ª–∞–≥–∏–Ω (—Ä–∞–±–æ—Ç–∞—é—â–∏–π –≤ Infinite Yield)
```lua
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

return {
    ["PluginName"] = "SuperSmartPathfinder",
    ["PluginDescription"] = "Baritone-—É—Ä–æ–≤–µ–Ω—å Pathfinding —Å –ø–∞—Ä–∫—É—Ä–æ–º –¥–ª—è Roblox",
    ["Commands"] = {
        ["smarttap"] = {
            ["ListName"] = "smarttap",
            ["Description"] = "–í–∫–ª/–í—ã–∫–ª —É–º–Ω—ã–π Tap-to-Move",
            ["Function"] = function(args, speaker)
                local moving = false
                local smartTapEnabled = _G.smartTapEnabled or false
                local moveConnection = _G.smartTapConn or nil

                local function getCharacter(player)
                    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        return player.Character,
                               player.Character:FindFirstChild("HumanoidRootPart"),
                               player.Character:FindFirstChild("Humanoid")
                    end
                    return nil
                end

                local function drawPath(waypoints)
                    for i = 1, #waypoints - 1 do
                        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
                        local part = Instance.new("Part")
                        part.Anchored = true
                        part.Material = Enum.Material.Neon
                        part.Color = Color3.fromRGB(0, 255, 0)
                        part.CanCollide = false
                        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
                        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
                        part.Parent = workspace
                        Debris:AddItem(part, 0.5)
                    end
                end

                local function computePath(startPos, destination)
                    local path = PathfindingService:CreatePath({
                        AgentRadius = 2,
                        AgentHeight = 5,
                        AgentCanJump = true,
                        AgentCanClimb = true
                    })
                    path:ComputeAsync(startPos, destination)
                    if path.Status == Enum.PathStatus.Success then
                        local waypoints = path:GetWaypoints()
                        drawPath(waypoints)
                        return waypoints
                    end
                    return nil
                end

                local function followPath(humanoid, waypoints)
                    moving = true
                    for _, waypoint in ipairs(waypoints) do
                        if not moving then break end
                        humanoid:MoveTo(waypoint.Position)
                        local reached = humanoid.MoveToFinished:Wait()
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            humanoid.Jump = true
                        end
                        if not reached then break end
                    end
                    moving = false
                end

                smartTapEnabled = not smartTapEnabled
                _G.smartTapEnabled = smartTapEnabled

                if smartTapEnabled then
                    print("[üß† SMARTTAP] –í–∫–ª—é—á–µ–Ω!")
                    moveConnection = UserInputService.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 then
                            local mouse = Players.LocalPlayer:GetMouse()
                            local char, hrp, humanoid = getCharacter(Players.LocalPlayer)
                            if char and hrp and humanoid then
                                local path = computePath(hrp.Position, Vector3.new(mouse.Hit.X, mouse.Hit.Y, mouse.Hit.Z))
                                if path then followPath(humanoid, path) end
                            end
                        end
                    end)
                    _G.smartTapConn = moveConnection
                else
                    print("[üõë SMARTTAP] –í—ã–∫–ª—é—á–µ–Ω!")
                    if moveConnection then moveConnection:Disconnect() end
                end
            end
        },

        ["smartfollow"] = {
            ["ListName"] = "smartfollow",
            ["Description"] = "–°–ª–µ–¥–æ–≤–∞—Ç—å –∑–∞ –∏–≥—Ä–æ–∫–æ–º —Å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ–º –¥–≤–∏–∂–µ–Ω–∏—è",
            ["Function"] = function(args, speaker)
                local getPlayer = getgenv().getPlayer or shared.getPlayer
                if not getPlayer then
                    warn("getPlayer —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ IY")
                    return
                end

                local targetPlayers = getPlayer(args[1] or "nearest")
                if #targetPlayers == 0 then
                    warn("[‚ö† SMARTFOLLOW] –ò–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                    return
                end
                local target = targetPlayers[1]

                local function getCharacter(player)
                    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        return player.Character,
                               player.Character:FindFirstChild("HumanoidRootPart"),
                               player.Character:FindFirstChild("Humanoid")
                    end
                    return nil
                end

                local function drawPath(waypoints)
                    for i = 1, #waypoints - 1 do
                        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
                        local part = Instance.new("Part")
                        part.Anchored = true
                        part.Material = Enum.Material.Neon
                        part.Color = Color3.fromRGB(0, 255, 0)
                        part.CanCollide = false
                        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
                        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
                        part.Parent = workspace
                        Debris:AddItem(part, 0.5)
                    end
                end

                local function computePath(startPos, destination)
                    local path = PathfindingService:CreatePath({
                        AgentRadius = 2,
                        AgentHeight = 5,
                        AgentCanJump = true,
                        AgentCanClimb = true
                    })
                    path:ComputeAsync(startPos, destination)
                    if path.Status == Enum.PathStatus.Success then
                        local waypoints = path:GetWaypoints()
                        drawPath(waypoints)
                        return waypoints
                    end
                    return nil
                end

                local function followPath(humanoid, waypoints)
                    for _, waypoint in ipairs(waypoints) do
                        humanoid:MoveTo(waypoint.Position)
                        humanoid.MoveToFinished:Wait()
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            humanoid.Jump = true
                        end
                    end
                end

                print("[üß† SMARTFOLLOW] –°–ª–µ–¥—É—é –∑–∞ –∏–≥—Ä–æ–∫–æ–º:", target.Name)

                RunService.Heartbeat:Connect(function()
                    local char, hrp, humanoid = getCharacter(Players.LocalPlayer)
                    local targetChar, targetHRP = getCharacter(target)
                    if char and hrp and humanoid and targetChar and targetHRP then
                        local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.5)
                        local path = computePath(hrp.Position, predictedPos)
                        if path then followPath(humanoid, path) end
                    end
                end)
            end
        }
    }
}
```

---

üí° –¢–µ–ø–µ—Ä—å —ç—Ç–æ:
- **100% –≤ IY-—Ñ–æ—Ä–º–∞—Ç–µ**.
- –ö–∞–∂–¥–∞—è –∫–æ–º–∞–Ω–¥–∞ ‚Äî –≤ `["Commands"]` –≤–Ω—É—Ç—Ä–∏ `return`.
- –£–±—Ä–∞–Ω—ã –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –≤ IY –º–æ–≥—É—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è.
- `getPlayer` –±–µ—Ä—ë–º –Ω–µ –Ω–∞–ø—Ä—è–º—É—é, –∞ –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è.

---

‚ùì –•–æ—á–µ—à—å, —á—Ç–æ–±—ã —è **–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —Å—é–¥–∞ –¥–æ–±–∞–≤–∏–ª SmartPath, SmartParkour –∏ StopMove**, —á—Ç–æ–±—ã –ø–ª–∞–≥–∏–Ω –∏–º–µ–ª –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Å—Ä–∞–∑—É –≤ —Ä–∞–±–æ—á–µ–º IY-—Ñ–æ—Ä–º–∞—Ç–µ?  
–¢–æ–≥–¥–∞ –æ–Ω —Å—Ä–∞–∑—É –∑–∞—Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é.