local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local connections = {}
local moving = false
local smartTapEnabled = false
local parkourMode = false
local currentTarget = nil

--------------------------------------------------------
-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
--------------------------------------------------------
local function getCharacter(player)
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character,
               player.Character:FindFirstChild("HumanoidRootPart"),
               player.Character:FindFirstChildOfClass("Humanoid")
    end
    return nil, nil, nil
end

local function drawPath(waypoints)
    for i = 1, #waypoints - 1 do
        local p1, p2 = waypoints[i].Position, waypoints[i + 1].Position
        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.CanCollide = false
        part.Size = Vector3.new(0.15, 0.15, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Parent = workspace
        Debris:AddItem(part, 0.5)
    end
end

local function computePath(startPos, destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 3,
        Costs = {
            Water = math.huge
        }
    })
    path:ComputeAsync(startPos, destination)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        drawPath(waypoints)
        return waypoints
    else
        warn("[PATHFINDING] –ü—É—Ç—å –Ω–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω: " .. tostring(path.Status))
        return nil
    end
end

local function performParkourMove(humanoid, hrp, obstacle)
    if obstacle and obstacle:IsA("BasePart") then
        local posDiff = obstacle.Position.Y - hrp.Position.Y

        if posDiff > 2 and posDiff < 6 then
            humanoid.Jump = true
            task.wait(0.2)
            hrp.CFrame = hrp.CFrame + Vector3.new(0, posDiff + 2, 0)
        elseif posDiff >=6 and posDiff <=8 then
            humanoid.Jump = true
            task.wait(0.15)
            humanoid:Move(Vector3.new(0, 0, -1))
            task.wait(0.1)
            humanoid.Jump = true
        elseif posDiff >8 and posDiff < 12 then
            humanoid.Jump = true
            task.wait(0.1)
            hrp.CFrame = hrp.CFrame + Vector3.new(1.5, 3, 1.5)
        elseif posDiff >= 0 and posDiff <= 2 then
            humanoid:Move(Vector3.new(1, 0, 1))
        end
    end
end

local function followPathWithParkour(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()

        if not reached then
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {workspace.Terrain, hrp.Parent}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local direction = (waypoint.Position - hrp.Position)
            if direction.Magnitude > 0 then
                local ray = workspace:Raycast(hrp.Position, direction.Unit * 3, params)
                if ray then
                    performParkourMove(humanoid, hrp, ray.Instance)
                end
            end
        end

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end

        task.wait()
    end
    moving = false
end

local function followPathNormal(humanoid, hrp, waypoints)
    moving = true
    for _, waypoint in ipairs(waypoints) do
        if not moving then break end
        humanoid:MoveTo(waypoint.Position)
        humanoid.MoveToFinished:Wait()
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
        task.wait()
    end
    moving = false
end

local function followPath(humanoid, hrp, waypoints)
    if parkourMode then
        followPathWithParkour(humanoid, hrp, waypoints)
    else
        followPathNormal(humanoid, hrp, waypoints)
    end
end

--------------------------------------------------------
-- –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
--------------------------------------------------------
local function clearConnections()
    for i, conn in ipairs(connections) do
        if conn and conn.Connected then
            conn:Disconnect()
        end
    end
    table.clear(connections)
end

local function toggleSmartTap()
    if smartTapEnabled then
        clearConnections()
        smartTapEnabled = false
        print("[üõë SMARTTAP] –í—ã–∫–ª—é—á–µ–Ω.")
        return
    end

    smartTapEnabled = true
    print("[üß† SMARTTAP] –í–∫–ª—é—á–µ–Ω, –∫–ª–∏–∫–∞–π—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ!")

    local conn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mouse = localPlayer:GetMouse()
            local char, hrp, humanoid = getCharacter(localPlayer)
            if char and hrp and humanoid then
                local path = computePath(hrp.Position, mouse.Hit.p)
                if path then
                    followPath(humanoid, hrp, path)
                else
                    warn("[SMARTTAP] –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                end
            end
        end
    end)
    table.insert(connections, conn)
end

local function smartFollow(targetFilter)
    clearConnections()
    currentTarget = nil

    local targetPlayers
    if _G.getPlayer then
        targetPlayers = _G.getPlayer(targetFilter)
    else
        targetPlayers = {}
        if targetFilter == "nearest" then
            local shortestDist = math.huge
            local nearest = nil
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    local char, hrp = getCharacter(player)
                    local myChar, myHrp = getCharacter(localPlayer)
                    if hrp and myHrp then
                        local dist = (hrp.Position - myHrp.Position).Magnitude
                        if dist < shortestDist then
                            nearest = player
                            shortestDist = dist
                        end
                    end
                end
            end
            if nearest then
                targetPlayers = {nearest}
            end
        else
            for _, player in pairs(Players:GetPlayers()) do
                if player.Name:lower():find(targetFilter:lower()) then
                    table.insert(targetPlayers, player)
                end
            end
        end
    end

    if #targetPlayers == 0 then
        warn("[‚ö† SMARTFOLLOW] –ò–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    end

    currentTarget = targetPlayers[1]
    print("[üß† SMARTFOLLOW] –°–ª–µ–¥—É—é –∑–∞: " .. currentTarget.Name .. (parkourMode and " (–ü–∞—Ä–∫—É—Ä)" or ""))

    local conn = RunService.Heartbeat:Connect(function()
        if not moving and currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild("HumanoidRootPart") then
            local char, hrp, humanoid = getCharacter(localPlayer)
            local targetChar, targetHRP = currentTarget.Character, currentTarget.Character:FindFirstChild("HumanoidRootPart")
            if char and hrp and humanoid and targetChar and targetHRP then
                local predictedPos = targetHRP.Position + (targetHRP.Velocity * 0.5)
                local path = computePath(hrp.Position, predictedPos)
                if path then
                    followPath(humanoid, hrp, path)
                end
            end
        end
    end)
    table.insert(connections, conn)
end

local function smartPathXYZ(args)
    local char, hrp, humanoid = getCharacter(localPlayer)
    if not (char and hrp and humanoid) then
        warn("[SMARTPATH] –í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–∂ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.")
        return
    end

    if #args < 3 then
        warn("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: smartpath X Y Z")
        return
    end

    local x, y, z = tonumber(args[1]), tonumber(args), tonumber(args)
    if not (x and y and z) then
        warn("[SMARTPATH] –ù–µ–≤–µ—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã.")
        return
    end

    local goal = Vector3.new(x, y, z)
    local path = computePath(hrp.Position, goal)
    if path then
        followPath(humanoid, hrp, path)
    else
        warn("[SMARTPATH] –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    end
end

local function toggleParkour()
    parkourMode = not parkourMode
    print(parkourMode and "[ü§∏‚Äç‚ôÇÔ∏è PARKOUR MODE] –í–∫–ª—é—á–µ–Ω" or "[üö∂‚Äç‚ôÇÔ∏è PARKOUR MODE] –í—ã–∫–ª—é—á–µ–Ω")
end

local function stopMoving()
    moving = false
    clearConnections()
    local char, hrp, humanoid = getCharacter(localPlayer)
    if humanoid then
        humanoid:Move(Vector3.new(0,0,0))
    end
    print("[üõë STOPMOVE] –î–≤–∏–∂–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.")
end

--------------------------------------------------------
-- –ü–ª–∞–≥–∏–Ω
--------------------------------------------------------
local Plugin = {
    PluginName = "SuperSmartPathfinder",
    PluginDescription = "Baritone-—É—Ä–æ–≤–µ–Ω—å Pathfinding —Å toggle –ü–∞—Ä–∫—É—Ä–æ–º –¥–ª—è Roblox",
    Commands = {
        smarttap = {
            ListName = "smarttap",
            Description = "–í–∫–ª—é—á–∞–µ—Ç/–≤—ã–∫–ª—é—á–∞–µ—Ç —É–º–Ω–æ–µ Tap-to-Move",
            Aliases = {},
            Function = function(args, speaker)
                toggleSmartTap()
            end
        },
        smartfollow = {
            ListName = "smartfollow",
            Description = "–°–ª–µ–¥—É–µ—Ç –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–º –∏–≥—Ä–æ–∫–æ–º",
            Aliases = {},
            Function = function(args, speaker)
                smartFollow(args[1] or "nearest")
            end
        },
        smartpath = {
            ListName = "smartpath",
            Description = "–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—É—Ç–∏ –∫ –∑–∞–¥–∞–Ω–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º",
            Aliases = {},
            Function = function(args, speaker)
                smartPathXYZ(args)
            end
        },
        parkourmode = {
            ListName = "parkourmode",
            Description = "–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º –ø–∞—Ä–∫—É—Ä–∞",
            Aliases = {},
            Function = function(args, speaker)
                toggleParkour()
            end
        },
        stopmove = {
            ListName = "stopmove",
            Description = "–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ª—é–±–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ",
            Aliases = {},
            Function = function(args, speaker)
                stopMoving()
            end
        }
    }
}

return Plugin
