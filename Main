добавь в lidarrandom рандомную остановку на рандомное время, не особо большое, и не часто, просто чтоб он был чутка похож на человека

local Plugin = {
    PluginName = "AdaptiveLidarNavigatorWithRandomPause",
    PluginDescription = "Умный LIDAR навигатор с интеллектуальным обходом, паркуром и естественным случайным патрулированием с паузами",
    Commands = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local parkourMode = false
local followMode = nil
local currentTarget = nil
local connections = {}

local scanRadius = 120
local safeDistance = 4
local maxJumpHeight = 7
local updateInterval = 0.012
local rayCountBase = 400
local rayCountParkour = 700

local dangerTags = {"Damage", "Lava", "Fire", "Kill", "Trap", "Spike", "Acid", "Death"}

local function getCharacter(player)
    if not player then return nil,nil,nil end
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character, player.Character.HumanoidRootPart, player.Character:FindFirstChildOfClass("Humanoid")
    end
    return nil,nil,nil
end

local function isDangerPart(part)
    if not part or not part:IsA("BasePart") then return false end
    local name = part.Name:lower()
    for _, tag in pairs(dangerTags) do
        if name:find(tag:lower()) then return true end
    end
    if part:GetAttribute("Danger") == true then return true end
    return false
end

local function checkDangerNearby(pos, radius)
    local region = Region3.new(pos - Vector3.new(radius,radius,radius), pos + Vector3.new(radius,radius,radius))
    local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {localPlayer.Character}, 50)
    for _, part in pairs(parts) do
        if isDangerPart(part) then return true end
    end
    return false
end

local function isPathDangerous(startPos, endPos, excludeModel)
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {excludeModel}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), direction * distance, rayParams)
    if ray and isDangerPart(ray.Instance) then return true end
    return false
end

local function generateSphericalScanDirs(rayCount)
    local dirs = {}
    local goldenRatio = (1 + math.sqrt(5)) / 2
    for i = 0, rayCount - 1 do
        local theta = 2 * math.pi * i / goldenRatio
        local phi = math.acos(1 - 2 * (i + 0.5) / rayCount)
        local x = math.sin(phi) * math.cos(theta)
        local y = math.sin(phi) * math.sin(theta)
        local z = math.cos(phi)
        table.insert(dirs, Vector3.new(x, y, z))
    end
    return dirs
end

local scanDirs = generateSphericalScanDirs(rayCountBase)
local scanRadiusCurrent = scanRadius
local updateInterval = updateInterval

local lastPositions = {}
local stepSize = 8

local function drawPath(points, color)
    color = color or Color3.new(0.3, 0.7, 1)
    for i=1, #points-1 do
        local p1, p2 = points[i], points[i+1]
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.18, 0.18, (p1-p2).Magnitude)
        part.CFrame = CFrame.new((p1+p2)/2, p2)
        part.Material = Enum.Material.Neon
        part.Color = color
        part.Parent = Workspace
        Debris:AddItem(part, 3)
    end
end

local function tryJump(hrp, humanoid, nextPoint)
    if not nextPoint or not humanoid then return false end
    local yd = nextPoint.Y - hrp.Position.Y
    if yd > 1.5 and yd < maxJumpHeight and humanoid.FloorMaterial ~= Enum.Material.Air then
        local origin = hrp.Position + Vector3.new(0, 2, 0)
        local dirToNext = (nextPoint - hrp.Position).Unit
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local ray = Workspace:Raycast(origin + Vector3.new(0, 1.5, 0), dirToNext * stepSize, rayParams)
        if ray and not isDangerPart(ray.Instance) then
            humanoid.Jump = true
            task.wait(0.22)
            return true
        end
    end
    return false
end

local function avoidWallCollision(hrp, proposedPos)
    local character = hrp.Parent
    if not character then return proposedPos end
    local direction = (proposedPos - hrp.Position).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), direction * stepSize, rayParams)
    if ray and ray.Instance and not isDangerPart(ray.Instance) then
        for _, dirAlt in ipairs(scanDirs) do
            if direction:Dot(dirAlt) < 0.9 then
                local testRay = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), dirAlt * stepSize, rayParams)
                if not testRay then
                    return hrp.Position + dirAlt * stepSize
                end
            end
        end
        return hrp.Position
    else
        return proposedPos
    end
end

local function selectNextStep(hrp, targetPos, lastDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local bestScore = math.huge
    local bestPos, bestDir = nil, nil
    for _, dir in ipairs(scanDirs) do
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local ray = Workspace:Raycast(origin, dir * scanRadiusCurrent, rayParams)
        local pos = ray and ray.Position or origin + dir * scanRadiusCurrent
        if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) then
            pos = avoidWallCollision(hrp, pos)
            local dist = (pos - targetPos).Magnitude
            for _, prevPos in ipairs(lastPositions) do
                if prevPos and (pos - prevPos).Magnitude < stepSize * 0.5 then
                    dist = dist + 10
                end
            end
            local score = dist
            if lastDir and lastDir:Dot(dir) > 0.85 then
                score = score * 0.65
            end
            if score < bestScore then
                bestScore = score
                bestPos = pos
                bestDir = dir
            end
        end
    end
    if bestPos then
        table.insert(lastPositions, bestPos)
        if #lastPositions > 20 then
            table.remove(lastPositions, 1)
        end
    end
    return bestPos, bestDir
end

local function predictTargetFuturePosition(tgtHRP, velocityHistory)
    if #velocityHistory < 2 then return tgtHRP.Position end
    local last = velocityHistory[#velocityHistory]
    local prev = velocityHistory[#velocityHistory-1]
    local dt = last.Time - prev.Time
    if dt <= 0 then return tgtHRP.Position end
    local vel = (last.Position - prev.Position)/dt
    return last.Position + vel * 0.5
end

local function ultraLidarNavigate(hrp, humanoid, targetPos, targetVelHistory)
    moving = true
    local lastDir = nil
    local pathPoints = {hrp.Position}
    lastPositions = {}
    while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
        local predictedPos = targetVelHistory and predictTargetFuturePosition(targetPos, targetVelHistory) or targetPos
        local nextStep, chosenDir = selectNextStep(hrp, predictedPos, lastDir)
        if not nextStep then
            warn("[LIDAR] Нет безопасных путей!")
            break
        end
        if tryJump(hrp, humanoid, nextStep) then
            task.wait(parkourMode and 0.1 or 0.25)
        end
        humanoid:MoveTo(nextStep)
        humanoid.MoveToFinished:Wait()
        lastDir = chosenDir
        table.insert(pathPoints, nextStep)
        task.wait(updateInterval)
    end
    drawPath(pathPoints, Color3.fromRGB(50, 180, 255))
    moving = false
end

local function drawScanVisualization(hrp)
    local origin = hrp.Position + Vector3.new(0,2,0)
    for _, dir in ipairs(scanDirs) do
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local ray = Workspace:Raycast(origin, dir * scanRadiusCurrent, rayParams)
        local endPos = ray and ray.Position or origin + dir * scanRadiusCurrent
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.06, 0.06, (endPos - origin).Magnitude)
        part.CFrame = CFrame.new((origin + endPos) / 2, endPos)
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.Parent = Workspace
        Debris:AddItem(part, 1)
    end
end

local function clearConnections()
    for _, conn in ipairs(connections) do
        if conn and conn.Connected then conn:Disconnect() end
    end
    connections = {}
end

Plugin.Commands["lidartap"] = {
    ListName = "lidartap",
    Description = "Перемещение к точке ПКМ с LIDAR и обходом препятствий",
    Aliases = {},
    Function = function(args, speaker)
        if followMode == "lidartap" then
            clearConnections()
            moving = false
            followMode = nil
            print("[LIDAR] lidartap выключен")
            return
        end
        scanRadiusCurrent = scanRadius
        updateScanSettings()
        followMode = "lidartap"
        print("[LIDAR] lidartap включен, используйте ПКМ для движения")
        local conn = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                if moving then return end
                local mouse = localPlayer:GetMouse()
                local destination = mouse.Hit.p
                local char, hrp, humanoid = getCharacter(localPlayer)
                if char and hrp and humanoid then
                    coroutine.wrap(function()
                        ultraLidarNavigate(hrp, humanoid, destination)
                    end)()
                end
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["lidarfollow"] = {
    ListName = "lidarfollow [player]",
    Description = "Следовать за игроком с адаптивным LIDAR и обходом препятствий",
    Aliases = {},
    Function = function(args, speaker)
        clearConnections()
        local Players = game:GetService("Players")
        local targetFilter = args and args[1] or "nearest"
        local targetPlayers = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(targetFilter:lower()) then
                table.insert(targetPlayers, p)
            end
        end
        if #targetPlayers == 0 then
            warn("[LIDAR] Цель не найдена")
            return
        end
        currentTarget = targetPlayers[1]
        scanRadiusCurrent = scanRadius
        updateScanSettings()
        followMode = "lidarfollow"
        print("[LIDAR] Следую за "..currentTarget.Name)
        local conn = RunService.Heartbeat:Connect(function()
            if moving then return end
            if not currentTarget or not currentTarget.Character then return end
            local char, hrp, humanoid = getCharacter(localPlayer)
            local tgtChar, tgtHRP = getCharacter(currentTarget)
            if char and hrp and humanoid and tgtChar and tgtHRP then
                coroutine.wrap(function()
                    ultraLidarNavigate(hrp, humanoid, tgtHRP.Position)
                end)()
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["lidarchase"] = {
    ListName = "lidarchase [player]",
    Description = "Активное преследование с прогнозированием и паркуром",
    Aliases = {},
    Function = function(args, speaker)
        clearConnections()
        local Players = game:GetService("Players")
        local targetFilter = args and args[1] or "nearest"
        local targetPlayers = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(targetFilter:lower()) then
                table.insert(targetPlayers, p)
            end
        end
        if #targetPlayers == 0 then
            warn("[LIDAR] Цель не найдена")
            return
        end
        currentTarget = targetPlayers[1]
        parkourMode = true
        scanRadiusCurrent = 140
        updateScanSettings()
        followMode = "lidarchase"
        print("[LIDAR] Преследую "..currentTarget.Name)
        local targetVelHistory = {}
        local conn = RunService.Heartbeat:Connect(function()
            if moving then return end
            if not currentTarget or not currentTarget.Character then return end
            local tgtHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
            if not tgtHRP then return end
            table.insert(targetVelHistory, {Position = tgtHRP.Position, Time = os.clock()})
            if #targetVelHistory > 20 then table.remove(targetVelHistory, 1) end
            local char, hrp, humanoid = getCharacter(localPlayer)
            if char and hrp and humanoid then
                coroutine.wrap(function()
                    ultraLidarNavigate(hrp, humanoid, tgtHRP.Position, targetVelHistory)
                end)()
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["parkourmode"] = {
    ListName = "parkourmode",
    Description = "Вкл/выкл продвинутый паркур режим",
    Aliases = {},
    Function = function()
        parkourMode = not parkourMode
        updateScanSettings()
        print(parkourMode and "[LIDAR] Паркур включён" or "[LIDAR] Паркур выключен")
    end
}

Plugin.Commands["lidarrandom"] = {
    ListName = "lidarrandom",
    Description = "Интеллектуальное случайное патрулирование с естественными паузами и обучением новой карте",
    Aliases = {},
    Function = function()
        clearConnections()
        followMode = "lidarrandom"
        print("[LIDAR] Включено интеллектуальное случайное патрулирование")
        local char, hrp, humanoid = getCharacter(localPlayer)
        if not char or not hrp or not humanoid then return end
        moving = true
        coroutine.wrap(function()
            local exploredPoints = {}
            while moving do
                local tries = 0
                local candidatePos
                repeat
                    local dir = Vector3.new(math.random()*2-1, math.random()*0.4-0.2, math.random()*2-1).Unit
                    local dist = math.random(30, 80)
                    candidatePos = hrp.Position + dir * dist
                    local nearbyDanger = checkDangerNearby(candidatePos, safeDistance)
                    local exploredKey = string.format("%.2f_%.2f_%.2f", candidatePos.X, candidatePos.Y, candidatePos.Z)
                    local alreadyExplored = exploredPoints[exploredKey]
                    tries = tries + 1
                    if tries > 30 then break end
                until not nearbyDanger and not alreadyExplored

                if candidatePos and not exploredPoints[string.format("%.2f_%.2f_%.2f", candidatePos.X, candidatePos.Y, candidatePos.Z)] then
                    ultraLidarNavigate(hrp, humanoid, candidatePos)
                    local key = string.format("%.2f_%.2f_%.2f", candidatePos.X, candidatePos.Y, candidatePos.Z)
                    exploredPoints[key] = true
                end

                -- Случайная пауза 0.5...1.5 секунды с 20% вероятностью
                if math.random() < 0.2 then
                    local pauseTime = 0.5 + math.random()
                    task.wait(pauseTime)
                end

                task.wait(0.5)
            end
        end)()
    end
}

Plugin.Commands["lidarshow"] = {
    ListName = "lidarshow",
    Description = "Показать 3D визуализацию LIDAR",
    Aliases = {},
    Function = function()
        local char, hrp = getCharacter(localPlayer)
        if not hrp then
            print("[LIDAR] HumanoidRootPart не найден")
            return
        end
        drawScanVisualization(hrp)
        print("[LIDAR] Визуализация завершена")
    end
}

Plugin.Commands["lidarstop"] = {
    ListName = "lidarstop",
    Description = "Остановить все навигационные процессы и движение",
    Aliases = {"stop"},
    Function = function()
        clearConnections()
        moving = false
        parkourMode = false
        followMode = nil
        currentTarget = nil
        local char, hrp, humanoid = getCharacter(localPlayer)
        if humanoid then humanoid:Move(Vector3.new()) end
        print("[LIDAR] Навигация и движение остановлены")
    end
}

return Plugin

Цитаты:
[1] IMG_20250817_025546_903.jpg https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/88450565/70f7488d-985e-4f24-8d05-d826d1a3bba2/IMG_20250817_025546_903.jpg
