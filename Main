напиши скрипт еще раз, кстати на заметочку, в плагине pathfind должен прокладывать дорогу на порядок лучше чем метод "tap to move" раз так в 1000

local Plugin = {
    ["PluginName"] = "SmartPathfinderPlus",
    ["PluginDescription"] = "Improved smart pathfinder with ultra-efficient pathfinding, smart tap, follow and coordinate pathing with stop.",
    ["Commands"] = {
        ["smarttap"] = {
            ["ListName"] = "smarttap",
            ["Description"] = "Toggle ultra-smart tap to move using advanced pathfinding.",
            ["Aliases"] = {"stap"},
            ["Function"] = function(args, speaker)
                local player = game.Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local root = character:WaitForChild("HumanoidRootPart")
                local pathfindingService = game:GetService("PathfindingService")
                local mouse = player:GetMouse()

                if not _G.SmartTapEnabled then
                    _G.SmartTapEnabled = true
                    print("SmartTap enabled - click to move with intelligent pathfinding")

                    _G.SmartTapConnection = mouse.Button1Down:Connect(function()
                        if not _G.SmartTapEnabled then return end

                        local targetPosition = mouse.Hit.p

                        -- Compute and follow path repeatedly for dynamic obstacle handling
                        coroutine.wrap(function()
                            while _G.SmartTapEnabled do
                                local path = pathfindingService:CreatePath({
                                    AgentRadius = 2,
                                    AgentHeight = 5,
                                    AgentCanJump = false,  -- no infinite jump
                                    AgentCanClimb = true   -- allow ladder climbing
                                })

                                path:ComputeAsync(root.Position, targetPosition)

                                if path.Status == Enum.PathStatus.Success then
                                    -- Visualize path points
                                    for _, waypoint in pairs(path:GetWaypoints()) do
                                        local part = Instance.new("Part")
                                        part.Anchored = true
                                        part.CanCollide = false
                                        part.Size = Vector3.new(0.3,0.3,0.3)
                                        part.Shape = Enum.PartType.Ball
                                        part.Material = Enum.Material.Neon
                                        part.BrickColor = BrickColor.new("Bright green")
                                        part.Transparency = 0.5
                                        part.Position = waypoint.Position + Vector3.new(0,1,0)
                                        part.Parent = workspace
                                        game.Debris:AddItem(part, 2)
                                    end

                                    -- Walk through waypoints intelligently
                                    for _, waypoint in pairs(path:GetWaypoints()) do
                                        if not _G.SmartTapEnabled then break end

                                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                                            humanoid.Jump = true
                                        elseif waypoint.Action == Enum.PathWaypointAction.Climb then
                                            humanoid:MoveTo(waypoint.Position)
                                            repeat wait() until (root.Position - waypoint.Position).magnitude < 2 or not _G.SmartTapEnabled
                                        else
                                            humanoid:MoveTo(waypoint.Position)
                                            repeat wait() until (root.Position - waypoint.Position).magnitude < 2 or not _G.SmartTapEnabled
                                        end
                                    end

                                    break -- path followed successfully, exit loop
                                else
                                    -- If path blocked, retry every 0.5 seconds
                                    wait(0.5)
                                end
                            end
                        end)()
                    end)
                else
                    _G.SmartTapEnabled = false
                    if _G.SmartTapConnection then
                        _G.SmartTapConnection:Disconnect()
                        _G.SmartTapConnection = nil
                    end
                    humanoid:MoveTo(root.Position)
                    print("SmartTap disabled.")
                end
            end
        },

        ["smartfollow"] = {
            ["ListName"] = "smartfollow",
            ["Description"] = "Follow a player intelligently using pathfinding.",
            ["Function"] = function(args, speaker)
                local Players = game:GetService("Players")
                local pathfindingService = game:GetService("PathfindingService")
                local player = Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local root = character:WaitForChild("HumanoidRootPart")

                if not args[11] then
                    print("Usage: smartfollow [player]")
                    return
                end

                -- Find target players according to filters (simplified)
                local function findPlayers(filter)
                    local list = {}
                    if filter == "me" then
                        table.insert(list, player)
                    elseif filter == "all" then
                        for _,p in pairs(Players:GetPlayers()) do table.insert(list,p) end
                    elseif filter == "others" then
                        for _,p in pairs(Players:GetPlayers()) do if p ~= player then table.insert(list, p) end end
                    elseif string.sub(filter,1,1) == "@" then
                        local name = string.sub(filter, 2)
                        for _,p in pairs(Players:GetPlayers()) do
                            if p.Name:lower() == name:lower() then
                                table.insert(list, p)
                                break
                            end
                        end
                    else
                        for _,p in pairs(Players:GetPlayers()) do
                            if p.Name:lower() == filter:lower() then
                                table.insert(list,p)
                                break
                            end
                        end
                    end
                    return list
                end

                local targets = findPlayers(args[11])
                if #targets == 0 then
                    print("No players found with filter: "..args[11])
                    return
                end

                _G.SmartFollowEnabled = true
                local target = targets[11]

                coroutine.wrap(function()
                    while _G.SmartFollowEnabled do
                        if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                            local targetPos = target.Character.HumanoidRootPart.Position
                            local path = pathfindingService:CreatePath({
                                AgentRadius = 2,
                                AgentHeight = 5,
                                AgentCanJump = false,
                                AgentCanClimb = true
                            })
                            path:ComputeAsync(root.Position, targetPos)

                            if path.Status == Enum.PathStatus.Success then
                                -- Visualize path
                                for _, waypoint in pairs(path:GetWaypoints()) do
                                    local part = Instance.new("Part")
                                    part.Anchored = true
                                    part.CanCollide = false
                                    part.Size = Vector3.new(0.3,0.3,0.3)
                                    part.Shape = Enum.PartType.Ball
                                    part.Material = Enum.Material.Neon
                                    part.BrickColor = BrickColor.new("Bright blue")
                                    part.Transparency = 0.5
                                    part.Position = waypoint.Position + Vector3.new(0,1,0)
                                    part.Parent = workspace
                                    game.Debris:AddItem(part, 1)
                                end

                                for _, waypoint in pairs(path:GetWaypoints()) do
                                    if not _G.SmartFollowEnabled then break end
                                    if waypoint.Action == Enum.PathWaypointAction.Jump then
                                        humanoid.Jump = true
                                    elseif waypoint.Action == Enum.PathWaypointAction.Climb then
                                        humanoid:MoveTo(waypoint.Position)
                                        repeat wait() until (root.Position - waypoint.Position).magnitude < 2 or not _G.SmartFollowEnabled
                                    else
                                        humanoid:MoveTo(waypoint.Position)
                                        repeat wait() until (root.Position - waypoint.Position).magnitude < 2 or not _G.SmartFollowEnabled
                                    end
                                end
                            else
                                humanoid:MoveTo(targetPos)
                                wait(0.5)
                            end
                        else
                            print("Target player lost or humanoid root missing.")
                            break
                        end
                        wait(0.3)
                    end
                end)()
            end
        },

        ["smartpath"] = {
            ["ListName"] = "smartpath",
            ["Description"] = "Create a smart path to given coordinates.",
            ["Function"] = function(args, speaker)
                if #args < 3 then
                    print("Usage: smartpath x y z")
                    return
                end

                local x, y, z = tonumber(args[11]), tonumber(args[12]), tonumber(args[13])
                if not (x and y and z) then
                    print("Invalid coordinates")
                    return
                end

                local targetPos = Vector3.new(x, y, z)
                local player = game.Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local root = character:WaitForChild("HumanoidRootPart")
                local pathfindingService = game:GetService("PathfindingService")

                local path = pathfindingService:CreatePath({
                    AgentRadius = 2,
                    AgentHeight = 5,
                    AgentCanJump = false,
                    AgentCanClimb = true
                })

                path:ComputeAsync(root.Position, targetPos)

                if path.Status == Enum.PathStatus.Success then
                    for _, waypoint in pairs(path:GetWaypoints()) do
                        local part = Instance.new("Part")
                        part.Anchored = true
                        part.CanCollide = false
                        part.Size = Vector3.new(0.3, 0.3, 0.3)
                        part.Shape = Enum.PartType.Ball
                        part.Material = Enum.Material.Neon
                        part.BrickColor = BrickColor.new("Bright yellow")
                        part.Transparency = 0.5
                        part.Position = waypoint.Position + Vector3.new(0,1,0)
                        part.Parent = workspace
                        game.Debris:AddItem(part, 3)
                    end

                    for _, waypoint in pairs(path:GetWaypoints()) do
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            humanoid.Jump = true
                        elseif waypoint.Action == Enum.PathWaypointAction.Climb then
                            humanoid:MoveTo(waypoint.Position)
                            repeat wait() until (root.Position - waypoint.Position).magnitude < 2
                        else
                            humanoid:MoveTo(waypoint.Position)
                            repeat wait() until (root.Position - waypoint.Position).magnitude < 2
                        end
                    end
                else
                    print("Failed to find path to target location")
                end
            end
        },

        ["stopmove"] = {
            ["ListName"] = "stopmove",
            ["Description"] = "Stop all smart pathfinding and movement.",
            ["Function"] = function(args,speaker)
                _G.SmartTapEnabled = false
                _G.SmartFollowEnabled = false
                if _G.SmartTapConnection then
                    _G.SmartTapConnection:Disconnect()
                    _G.SmartTapConnection = nil
                end

                local player = game.Players.LocalPlayer
                local character = player.Character
                if character then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    local root = character:FindFirstChild("HumanoidRootPart")
                    if humanoid and root then
                        humanoid:MoveTo(root.Position)
                    end
                end

                print("All smart movements stopped.")
            end
        }
    }
}

return Plugin

Цитаты:
[1] SimplePath - Pathfinding Module - Developer Forum | Roblox https://devforum.roblox.com/t/simplepath-pathfinding-module/1196762
[2] How efficient is the built-in PathfindingService? - Scripting Support https://devforum.roblox.com/t/how-efficient-is-the-built-in-pathfindingservice/445903
[3] How To Use Pathfinding Service In Roblox - Community Tutorials https://devforum.roblox.com/t/how-to-use-pathfinding-service-in-roblox/881628
[4] NPC :MoveTo has a stuttering effect whilst using PathfindingService https://devforum.roblox.com/t/npc-moveto-has-a-stuttering-effect-whilst-using-pathfindingservice/3067241
[5] Improving Pathfinding Quality With New Algorithm - Announcements https://devforum.roblox.com/t/improving-pathfinding-quality-with-new-algorithm/3258657
[6] Pathfinding (AI, Dynamic Paths, Modifiers) - Roblox ... - YouTube https://www.youtube.com/watch?v=ckA4fVkAjIA
[7] Faster, smarter and more efficient AI pathfinding needed https://devforum.roblox.com/t/faster-smarter-and-more-efficient-ai-pathfinding-needed/1624451
[8] Deep dive on performance of NPCs and :MoveTo() https://devforum.roblox.com/t/deep-dive-on-performance-of-npcs-and-moveto/2650505
[9] Is there a way to make Pathfinding service work on client? https://devforum.roblox.com/t/is-there-a-way-to-make-pathfinding-service-work-on-client/867033
[10] PathfindingService doesn't always use agent params; makes service ... https://devforum.roblox.com/t/pathfindingservice-doesnt-always-use-agent-params-makes-service-unusable-for-large-characters/1394948
[11] Infinite Yield plugin and theme manager - GitHub https://github.com/Infinite-Store/Infinite-Store
[12] Шесть открытых библиотек от Mad Brains, которые упростят жизнь Flutter-разработчика — Разработка на vc.ru https://vc.ru/dev/641642-shest-otkrytyh-bibliotek-ot-mad-brains-kotorye-uprostyat-zhizn-flutter-razrabotchika
[13] Infinite Library, easily install Infinite Yield Plugins - Reddit https://www.reddit.com/r/ROBLOXExploiting/comments/1isdqzx/infinite_library_easily_install_infinite_yield/
