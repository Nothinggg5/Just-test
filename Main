когда Врубаешь хоть одну из функций, начинает жутко лагать но ничего не происходит, персонаж не двигается больше вообще, исправляй все 3 функции

local Plugin = {
    PluginName = "OptimizedUltimateLidarNavigator",
    PluginDescription = "Оптимизированный LIDAR навигатор с 360° обзора, улучшенной навигацией, преследованием и следованием",
    Commands = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer

local moving = false
local parkourMode = false
local followMode = nil
local currentTarget = nil
local connections = {}

local scanRadiusBase = 120 -- снижено радиус для оптимизации
local safeDistance = 3
local maxJumpHeight = 6
local updateIntervalBase = 0.05 -- увеличен интервал для снижения нагрузки

local dangerTags = {"damage", "lava", "fire", "kill", "trap", "spike", "acid", "death"}

local exploredMap = {}

local function getCharacter(player)
    if not player or not player.Character then return nil, nil, nil end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return player.Character, hrp, humanoid
end

local function isDangerPart(part)
    if not part or not part:IsA("BasePart") then return false end
    local name = part.Name:lower()
    for _, tag in pairs(dangerTags) do
        if name:find(tag) then return true end
    end
    if part:GetAttribute("Danger") == true then return true end
    return false
end

local function checkDangerNearby(pos, radius)
    local region = Region3.new(pos - Vector3.new(radius,radius,radius), pos + Vector3.new(radius,radius,radius))
    local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {localPlayer.Character}, 30)
    for _, p in pairs(parts) do
        if isDangerPart(p) then return true end
    end
    return false
end

local function isPathDangerous(startPos, endPos, excludeModel)
    local dir = (endPos - startPos).Unit
    local dist = (endPos - startPos).Magnitude
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {excludeModel}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(startPos, dir * dist, rayParams)
    return ray and isDangerPart(ray.Instance)
end

local function generateFullSpherePoints(radius, steps)
    local points = {}
    for i = 0, steps do
        local theta = math.pi * i / steps
        for j = 0, 2 * steps do
            local phi = 2 * math.pi * j / (2 * steps)
            local x = radius * math.sin(theta) * math.cos(phi)
            local y = radius * math.cos(theta)
            local z = radius * math.sin(theta) * math.sin(phi)
            table.insert(points, Vector3.new(x, y, z))
        end
    end
    return points
end

local scanPoints = generateFullSpherePoints(scanRadiusBase, 12)
local lastPositions = {}
local stepSize = 7 -- уменьшено для более плавного движения

local function isSafeToMoveTo(position, hrp)
    local rayOrigin = position + Vector3.new(0, 2, 0)
    local rayDirection = Vector3.new(0, -5, 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {hrp.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(rayOrigin, rayDirection, rayParams)
    return ray and not isDangerPart(ray.Instance)
end

local function avoidObstacles(hrp, proposedPos)
    local char = hrp.Parent
    if not char then return proposedPos end
    local dir = (proposedPos - hrp.Position).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {char}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local offsets = {
        dir,
        (dir + Vector3.new(1, 0, 0)).Unit,
        (dir + Vector3.new(-1, 0, 0)).Unit,
        (dir + Vector3.new(0, 0, 1)).Unit,
        (dir + Vector3.new(0, 0, -1)).Unit,
        (dir + Vector3.new(1, 0, 1)).Unit,
        (dir + Vector3.new(-1, 0, 1)).Unit,
        (dir + Vector3.new(1, 0, -1)).Unit,
        (dir + Vector3.new(-1, 0, -1)).Unit,
    }

    for _, altDir in ipairs(offsets) do
        local ray = Workspace:Raycast(hrp.Position + Vector3.new(0, 2, 0), altDir * stepSize, rayParams)
        if not ray or isDangerPart(ray.Instance) then
            if isSafeToMoveTo(hrp.Position + altDir * stepSize, hrp) then
                return hrp.Position + altDir * stepSize
            end
        end
    end
    return hrp.Position
end

local function selectNextStepAmbient(hrp, targetPos, lastDir)
    local origin = hrp.Position + Vector3.new(0, 2, 0)
    local bestScore = math.huge
    local bestPos, bestDir = nil, nil

    for _, offset in ipairs(scanPoints) do
        local pos = origin + offset
        if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) and isSafeToMoveTo(pos, hrp) then
            pos = avoidObstacles(hrp, pos)
            local dist = (pos - targetPos).Magnitude
            for _, prevPos in ipairs(lastPositions) do
                if prevPos and (pos - prevPos).Magnitude < stepSize * 0.6 then
                    dist = dist + 15
                end
            end
            local score = dist
            if lastDir and lastDir:Dot(offset.Unit) > 0.85 then
                score = score * 0.7
            end
            if score < bestScore then
                bestScore = score
                bestPos = pos
                bestDir = offset.Unit
            end
        end
    end

    if bestPos then
        table.insert(lastPositions, bestPos)
        if #lastPositions > 20 then
            table.remove(lastPositions, 1)
        end
    end

    return bestPos, bestDir
end

local function enhancedStepUp(hrp, humanoid, nextPoint)
    if not nextPoint or not humanoid then return false end
    if humanoid.FloorMaterial == Enum.Material.Air then return false end

    local verticalDist = nextPoint.Y - hrp.Position.Y
    local horizDist = (Vector3.new(nextPoint.X, 0, nextPoint.Z) - Vector3.new(hrp.Position.X, 0, hrp.Position.Z)).Magnitude

    if verticalDist <= 0 or verticalDist > maxJumpHeight or horizDist > stepSize * 1.2 then
        return false
    end

    local origin = hrp.Position + Vector3.new(0, 1.3, 0)
    local forward = (nextPoint - hrp.Position).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {hrp.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local obstacleRay = Workspace:Raycast(origin, forward * stepSize, rayParams)
    local headClearRay = Workspace:Raycast(hrp.Position + Vector3.new(0, 2.8, 0), forward * stepSize, rayParams)

    if obstacleRay and not isDangerPart(obstacleRay.Instance) and not headClearRay then
        humanoid.Jump = true
        task.wait(0.2)
        return true
    end

    return false
end

local function predictTargetFuturePosition(tgtHRP, history)
    if #history < 2 then return tgtHRP.Position end
    local last = history[#history]
    local prev = history[#history - 1]
    local dt = last.Time - prev.Time
    if dt <= 0 then return tgtHRP.Position end
    local velocity = (last.Position - prev.Position) / dt
    return last.Position + velocity * 0.8
end

local function ultraLidarNavigate(hrp, humanoid, targetPos, targetVelHistory)
    moving = true
    local lastDir = nil
    local pathPoints = {hrp.Position}
    lastPositions = {}

    while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
        local predictedPos = targetVelHistory and predictTargetFuturePosition(targetPos, targetVelHistory) or targetPos
        local nextStep, chosenDir = selectNextStepAmbient(hrp, predictedPos, lastDir)

        if not nextStep then
            warn("[LIDAR] Нет безопасных путей, прерываю навигацию")
            break
        end

        if enhancedStepUp(hrp, humanoid, nextStep) then
            task.wait(parkourMode and 0.1 or 0.25)
        end

        humanoid:MoveTo(nextStep)
        humanoid.MoveToFinished:Wait()

        lastDir = chosenDir
        table.insert(pathPoints, nextStep)

        local key = string.format("%.1f_%.1f_%.1f", nextStep.X, nextStep.Y, nextStep.Z)
        exploredMap[key] = true

        task.wait(updateIntervalBase)
    end

    for i = 1, #pathPoints-1 do
        local p1, p2 = pathPoints[i], pathPoints[i + 1]
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.2, 0.2, (p1 - p2).Magnitude)
        part.CFrame = CFrame.new((p1 + p2) / 2, p2)
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(50, 160, 255)
        part.Parent = Workspace
        Debris:AddItem(part, 3)
    end

    moving = false
end

local function clearConnections()
    for _, conn in ipairs(connections) do
        if conn and conn.Connected then
            conn:Disconnect()
        end
    end
    connections = {}
    lastPositions = {}
    moving = false
    followMode = nil
    currentTarget = nil
end

Plugin.Commands["lidarrandom"] = {
    ListName = "lidarrandom",
    Description = "Интеллектуальное изучение всей карты с запоминанием и обходом опасностей",
    Aliases = {},
    Function = function()
        clearConnections()
        local char, hrp, humanoid = getCharacter(localPlayer)
        if not char or not hrp or not humanoid then
            warn("[LIDAR] Персонаж или компоненты не найдены")
            return
        end
        followMode = "lidarrandom"
        print("[LIDAR] Запущено интеллектуальное изучение карты")
        moving = true
        coroutine.wrap(function()
            while moving do
                local tries = 0
                local candidatePos
                repeat
                    local dir = Vector3.new(math.random()*2-1, math.random()*0.4-0.2, math.random()*2-1).Unit
                    local dist = math.random(40, 100)
                    candidatePos = hrp.Position + dir * dist
                    local nearbyDanger = checkDangerNearby(candidatePos, safeDistance)
                    local key = string.format("%.1f_%.1f_%.1f", candidatePos.X, candidatePos.Y, candidatePos.Z)
                    local alreadyExplored = exploredMap[key]
                    tries = tries + 1
                    if tries > 50 then
                        candidatePos = nil
                        break
                    end
                until not nearbyDanger and not alreadyExplored
                if candidatePos then
                    ultraLidarNavigate(hrp, humanoid, candidatePos)
                end
                if math.random() < 0.4 then
                    task.wait(0.7 + math.random() * 0.3)
                end
                task.wait(0.5)
            end
        end)()
    end
}

Plugin.Commands["lidarfollow"] = {
    ListName = "lidarfollow [player]",
    Description = "Следование за игроком, обходя препятствия",
    Aliases = {},
    Function = function(args)
        clearConnections()
        local Players = game:GetService("Players")
        local filter = args and args[1] or "nearest"
        local targets = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(filter:lower()) then
                table.insert(targets, p)
            end
        end
        if #targets == 0 then
            warn("[LIDAR] Цель не найдена")
            return
        end
        currentTarget = targets[1]
        followMode = "lidarfollow"
        print("[LIDAR] Следую за "..currentTarget.Name)
        local conn = RunService.Heartbeat:Connect(function()
            if moving then return end
            if not currentTarget or not currentTarget.Character then return end
            local char, hrp, humanoid = getCharacter(localPlayer)
            local tgtChar, tgtHRP = getCharacter(currentTarget)
            if char and hrp and humanoid and tgtChar and tgtHRP then
                coroutine.wrap(function()
                    ultraLidarNavigate(hrp, humanoid, tgtHRP.Position)
                end)()
            end
        end)
        table.insert(connections, conn)
    end
}

Plugin.Commands["lidarchase"] = {
    ListName = "lidarchase [player]",
    Description = "Активное преследование с прогнозом позиций и засадами",
    Aliases = {},
    Function = function(args)
        clearConnections()
        local Players = game:GetService("Players")
        local filter = args and args[1] or "nearest"
        local targets = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(filter:lower()) then
                table.insert(targets, p)
            end
        end
        if #targets == 0 then
            warn("[LIDAR] Цель не найдена")
            return
        end
        currentTarget = targets[1]
        parkourMode = true
        updateScanSettings()
        followMode = "lidarchase"
        print("[LIDAR] Начинаю преследование "..currentTarget.Name)
        local targetVelHistory = {}
        local conn = RunService.Heartbeat:Connect(function()
            if moving then return end
            if not currentTarget or not currentTarget.Character then return end
            local tgtHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
            if not tgtHRP then return end
            table.insert(targetVelHistory, {Position = tgtHRP.Position, Time = os.clock()})
            if #targetVelHistory > 20 then
                table.remove(targetVelHistory, 1)
            end
            local char, hrp, humanoid = getCharacter(localPlayer)
            if char and hrp and humanoid then
                coroutine.wrap(function()
                    local predictedPos = predictTargetFuturePosition(tgtHRP, targetVelHistory)
                    local offsDir = (predictedPos - tgtHRP.Position).Unit
                    local ambushPos = tgtHRP.Position + offsDir * 7
                    ultraLidarNavigate(hrp, humanoid, ambushPos, targetVelHistory)
                end)()
            end
        end)
        table.insert(connections, conn)
    end
}

function updateScanSettings()
    if parkourMode then
        scanRadiusBase = 160
        updateIntervalBase = 0.015
        scanPoints = generateFullSpherePoints(scanRadiusBase, 20)
    else
        scanRadiusBase = 120
        updateIntervalBase = 0.05
        scanPoints = generateFullSpherePoints(scanRadiusBase, 12)
    end
end

Plugin.Commands["lidarshow"] = {
    ListName = "lidarshow",
    Description = "Визуализация всех LIDAR лучей для обзора 360°",
    Aliases = {},
    Function = function()
        local char, hrp = getCharacter(localPlayer)
        if not hrp then
            print("[LIDAR] HumanoidRootPart не найден")
            return
        end
        local origin = hrp.Position + Vector3.new(0, 2, 0)
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {hrp.Parent}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist

        for _, offset in ipairs(scanPoints) do
            local ray = Workspace:Raycast(origin, offset, rayParams)
            local endPos = ray and ray.Position or (origin + offset)
            local part = Instance.new("Part")
            part.Anchored = true
            part.CanCollide = false
            part.Size = Vector3.new(0.05, 0.05, (endPos - origin).Magnitude)
            part.CFrame = CFrame.new((origin + endPos) / 2, endPos)
            part.Material = Enum.Material.Neon
            part.Color = Color3.fromRGB(0, 255, 0)
            part.Parent = Workspace
            Debris:AddItem(part, 1.5)
        end
        print("[LIDAR] Визуализация завершена")
    end
}

return Plugin

Цитаты:
[1] IMG_20250817_025546_903.jpg https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/88450565/70f7488d-985e-4f24-8d05-d826d1a3bba2/IMG_20250817_025546_903.jpg
