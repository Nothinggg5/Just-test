local Plugin = {
    ["PluginName"] = "SmartMovement",
    ["PluginDescription"] = "Advanced movement commands with smart pathfinding, following, and tap to move using Roblox PathfindingService with controlled jumping and optimized navigation.",
    ["Commands"] = {},
    ["State"] = {
        SmartTapEnabled = false,
        PathfindingAgent = nil,
        CurrentTask = nil,
        LastJumpTime = 0,
        JumpCooldown = 0.6,  -- Adjusted cooldown to allow controlled jumps (prevents infinite air jumps)
    }
}

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- Utility to draw debug path lines simulating "thinking"
local function debugDrawPath(path)
    for i = 1, #path - 1 do
        local part0 = Instance.new("Part")
        part0.Anchored = true
        part0.CanCollide = false
        part0.Size = Vector3.new(0.15, 0.15, (path[i].Position - path[i + 1].Position).Magnitude)
        part0.CFrame = CFrame.new(path[i].Position:Lerp(path[i + 1].Position, 0.5), path[i + 1].Position)
        part0.Transparency = 0.6
        part0.BrickColor = BrickColor.new("Lime green")
        part0.Parent = workspace
        game.Debris:AddItem(part0, 3)
    end
end

-- Detect if the part is a ladder (customize detection as needed)
local function isLadder(part)
    if not part then return false end
    local name = part.Name:lower()
    return name:find("ladder") or (part.Material == Enum.Material.Wood and part.Shape == Enum.PartType.Cylinder)
end

-- Controlled jumping to prevent infinite air jumps
local function canJump()
    local now = tick()
    if now - Plugin.State.LastJumpTime >= Plugin.State.JumpCooldown then
        Plugin.State.LastJumpTime = now
        return true
    end
    return false
end

-- Move character along generated path waypoints with ladder climbing support
local function moveCharacterAlongPath(waypoints)
    local humanoid = Character:FindFirstChildOfClass("Humanoid")
    local hrp = Character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end

    local index = 1
    local function step()
        if not Character.Parent then
            if Plugin.State.CurrentTask then
                Plugin.State.CurrentTask:Disconnect()
                Plugin.State.CurrentTask = nil
            end
            return
        end

        if index > #waypoints then
            humanoid:Move(Vector3.new(0, 0, 0))
            if Plugin.State.CurrentTask then
                Plugin.State.CurrentTask:Disconnect()
                Plugin.State.CurrentTask = nil
            end
            return
        end

        local waypoint = waypoints[index]
        local pos = hrp.Position
        local targetPos = waypoint.Position
        local direction = (targetPos - pos)
        local dist = direction.Magnitude

        -- Handling climbing based on PathWaypointAction and environment detection
        if waypoint.Action == Enum.PathWaypointAction.Climb then
            local rayOrigin = pos + Vector3.new(0, 3, 0)
            local rayDirection = Vector3.new(0, -6, 0)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {workspace}
            raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
            local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

            if raycastResult and isLadder(raycastResult.Instance) then
                humanoid.Jump = false
                -- Smoothly move character upward along ladder instead of jumping endlessly
                hrp.CFrame = CFrame.new(targetPos)
                index = index + 1
                return
            end
        end

        -- Close enough to waypoint, proceed to next
        if dist < 3 then
            index = index + 1
        else
            local moveDir = direction.Unit
            local humState = humanoid:GetState()

            -- Handle jumping with cooldown to prevent infinite jumping
            if humState == Enum.HumanoidStateType.Freefall or humState == Enum.HumanoidStateType.Jumping then
                if canJump() then
                    humanoid.Jump = true
                else
                    humanoid.Jump = false
                end
            else
                humanoid.Jump = false
            end

            humanoid:Move(moveDir, false)
        end
    end

    if Plugin.State.CurrentTask then
        Plugin.State.CurrentTask:Disconnect()
        Plugin.State.CurrentTask = nil
    end
    Plugin.State.CurrentTask = RunService.Heartbeat:Connect(step)
end

-- Execute improved pathfinding with retries and optimized parameters
local function moveToPosition(targetPosition)
    local humanoid = Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local maxAttempts = 5
    local computedPath = nil

    for i = 1, maxAttempts do
        local path = PathfindingService:CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentJumpHeight = 7,
            AgentMaxSlope = 65,
            CostMultiplier = 0.5
        })
        path:ComputeAsync(hrp.Position, targetPosition)
        if path.Status == Enum.PathStatus.Success then
            computedPath = path
            break
        end
        task.wait(0.1)  -- Small wait before retry
    end

    if computedPath then
        local waypoints = computedPath:GetWaypoints()
        debugDrawPath(waypoints)
        moveCharacterAlongPath(waypoints)
    else
        warn("SmartMovement: Failed to compute path after "..maxAttempts.." attempts.")
    end
end

-- Player target identifier parser (supports various selectors)
local function findPlayerByIdentifier(identifier)
    if not identifier or #identifier == 0 then return {} end
    identifier = identifier:lower()

    if identifier == "me" then
        return {LocalPlayer}
    elseif identifier == "all" then
        return Players:GetPlayers()
    elseif identifier == "others" then
        local list = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer then table.insert(list, p) end
        end
        return list
    elseif identifier:sub(1, 1) == "@" then
        local username = identifier:sub(2)
        local player = Players:FindFirstChild(username)
        if player then return {player} end
        local matches = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p.Name:lower() == username then
                table.insert(matches, p)
            end
        end
        return matches
    elseif identifier == "random" then
        local plist = Players:GetPlayers()
        if #plist == 0 then return {} end
        return {plist[math.random(1, #plist)]}
    elseif identifier:sub(1, 1) == "%" then
        local teamName = identifier:sub(2)
        local teamPlayers = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p.Team and p.Team.Name:lower() == teamName then
                table.insert(teamPlayers, p)
            end
        end
        return teamPlayers
    elseif identifier == "nearest" then
        local nearestPlayer = nil
        local nearestDistance = math.huge
        for _, p in pairs(Players:GetPlayers()) do
            if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (p.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if dist < nearestDistance then
                    nearestDistance = dist
                    nearestPlayer = p
                end
            end
        end
        return nearestPlayer and {nearestPlayer} or {}
    else
        -- Partial name match fallback
        local matches = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p.Name:lower():find(identifier) then
                table.insert(matches, p)
            end
        end
        return matches
    end
end

-- Command: toggles smarttap on/off; moves player to clicked location using pathfinding
Plugin.Commands["smarttap"] = {
    ["ListName"] = "smarttap",
    ["Description"] = "Toggle smart tap to move (pathfinding-based)",
    ["Aliases"] = {"stap"},
    ["Function"] = function(args)
        Plugin.State.SmartTapEnabled = not Plugin.State.SmartTapEnabled
        if Plugin.State.SmartTapEnabled then
            local mouse = LocalPlayer:GetMouse()
            local conn
            conn = mouse.Button1Down:Connect(function()
                if not Plugin.State.SmartTapEnabled then
                    conn:Disconnect()
                    return
                end
                local target = mouse.Hit.Position
                moveToPosition(target)
            end)
            Plugin.State.SmartTapConnection = conn
            print("SmartTap enabled")
        else
            if Plugin.State.SmartTapConnection then
                Plugin.State.SmartTapConnection:Disconnect()
                Plugin.State.SmartTapConnection = nil
            end
            if Plugin.State.CurrentTask then
                Plugin.State.CurrentTask:Disconnect()
                Plugin.State.CurrentTask = nil
            end
            print("SmartTap disabled")
        end
    end
}

-- Command: smartfollow follows the specified player with dynamic path updates using smart pathfinding
Plugin.Commands["smartfollow"] = {
    ["ListName"] = "smartfollow",
    ["Description"] = "Follow a specified player smartly with pathfinding",
    ["Aliases"] = {"sfollow"},
    ["Function"] = function(args)
        if not args[1] then
            print("Usage: smartfollow <player identifier>")
            return
        end
        local targets = findPlayerByIdentifier(args[1])
        if #targets == 0 then
            print("No matching player found for: "..args[1])
            return
        end
        local target = targets[1]
        print("Following player:", target.Name)
        if Plugin.State.CurrentTask then
            Plugin.State.CurrentTask:Disconnect()
            Plugin.State.CurrentTask = nil
        end

        local humanoid = Character:FindFirstChildOfClass("Humanoid")
        if not humanoid then
            print("Humanoid not found")
            return
        end

        local followConn
        followConn = RunService.Heartbeat:Connect(function()
            if not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then return end
            if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end

            local targetPos = target.Character.HumanoidRootPart.Position
            local currentPos = Character.HumanoidRootPart.Position
            local dist = (targetPos - currentPos).Magnitude

            if dist > 5 then
                moveToPosition(targetPos)
            else
                humanoid:Move(Vector3.new(0, 0, 0))
            end
        end)

        Plugin.State.CurrentTask = followConn
    end
}

-- Command: smartpath moves player to specified coordinates intelligently
Plugin.Commands["smartpath"] = {
    ["ListName"] = "smartpath",
    ["Description"] = "Move to specified position smartly using pathfinding",
    ["Aliases"] = {"spath"},
    ["Function"] = function(args)
        if #args < 3 then
            print("Usage: smartpath <x> <y> <z>")
            return
        end
        local x = tonumber(args[1])
        local y = tonumber(args[2])
        local z = tonumber(args[3])
        if not x or not y or not z then
            print("Invalid coordinates; usage: smartpath <x> <y> <z>")
            return
        end
        moveToPosition(Vector3.new(x, y, z))
    end
}

-- Command: stopmove disables all movement and cancels ongoing pathfinding tasks
Plugin.Commands["stopmove"] = {
    ["ListName"] = "stopmove",
    ["Description"] = "Stop all movement and ongoing tasks",
    ["Aliases"] = {"smove"},
    ["Function"] = function()
        if Plugin.State.SmartTapEnabled and Plugin.State.SmartTapConnection then
            Plugin.State.SmartTapConnection:Disconnect()
            Plugin.State.SmartTapConnection = nil
            Plugin.State.SmartTapEnabled = false
        end
        if Plugin.State.CurrentTask then
            Plugin.State.CurrentTask:Disconnect()
            Plugin.State.CurrentTask = nil
        end
        local humanoid = Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:Move(Vector3.new(0, 0, 0))
            humanoid.Jump = false
        end
        print("All movement stopped")
    end
}

return Plugin
