local Plugin = {
PluginName = "PerfectLidarPathfinder",
PluginDescription = "LIDAR навигатор с очень длинными 3D лучами, адаптивным преследованием и паркуром",
Commands = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local moving = false
local parkourMode = false
local followMode = nil
local currentTarget = nil
local connections = {}

local scanRadius = 80 -- действительно длинные лучи для замкнутых пространств
local safeDistance = 3
local maxJumpHeight = 7
local updateInterval = 0.015
local rayCountBase = 200 -- базовое количество лучей для полного охвата
local rayCountParkour = 350 -- для паркура еще больше лучей

local dangerTags = {"Damage", "Lava", "Fire", "Kill", "Trap", "Spike", "Acid", "Death"}

local function getCharacter(player)
if not player then return nil,nil,nil end
if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
return player.Character, player.Character.HumanoidRootPart, player.Character:FindFirstChildOfClass("Humanoid")
end
return nil,nil,nil
end

local function isDangerPart(part)
if not part or not part:IsA("BasePart") then return false end
local name = part.Name:lower()
for _, tag in pairs(dangerTags) do
if name:find(tag:lower()) then return true end
end
if part:GetAttribute("Danger") == true then return true end
return false
end

local function checkDangerNearby(pos, radius)
local region = Region3.new(pos - Vector3.new(radius,radius,radius), pos + Vector3.new(radius,radius,radius))
local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {localPlayer.Character}, 50)
for _, part in pairs(parts) do
if isDangerPart(part) then return true end
end
return false
end

local function isPathDangerous(startPos, endPos, excludeModel)
local direction = (endPos - startPos).Unit
local distance = (endPos - startPos).Magnitude
local rayParams = RaycastParams.new()
rayParams.FilterDescendantsInstances = {excludeModel}
rayParams.FilterType = Enum.RaycastFilterType.Blacklist
local ray = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), direction * distance, rayParams)
if ray and isDangerPart(ray.Instance) then return true end
return false
end

local function generateEvenSphericalDirs(numRays)
local dirs = {}
local goldenRatio = (1 + math.sqrt(5)) / 2
for i = 0, numRays - 1 do
local theta = 2 * math.pi * i / goldenRatio
local phi = math.acos(1 - 2 * (i + 0.5) / numRays)
local x = math.sin(phi) * math.cos(theta)
local y = math.sin(phi) * math.sin(theta)
local z = math.cos(phi)
table.insert(dirs, Vector3.new(x, y, z))
end
return dirs
end

local scanDirs = generateEvenSphericalDirs(rayCountBase)

local function updateScanSettings()
if parkourMode then
scanDirs = generateEvenSphericalDirs(rayCountParkour)
scanRadius = 90
updateInterval = 0.01
else
scanDirs = generateEvenSphericalDirs(rayCountBase)
scanRadius = 80
updateInterval = 0.02
end
end

local lastPositions = {}
local stepSize = 8

local function drawPath(points, color)
color = color or Color3.new(0.5, 0.85, 1)
for i = 1, #points - 1 do
local p1, p2 = points[i], points[i+1]
local part = Instance.new("Part")
part.Anchored = true
part.CanCollide = false
part.Size = Vector3.new(0.2, 0.2, (p1 - p2).Magnitude)
part.CFrame = CFrame.new((p1 + p2)/2, p2)
part.Material = Enum.Material.Neon
part.Color = color
part.Parent = Workspace
Debris:AddItem(part, 3)
end
end

local function tryJump(hrp, humanoid, nextPoint)
local yd = nextPoint.Y - hrp.Position.Y
if yd > 1.5 and yd < maxJumpHeight and humanoid and humanoid.FloorMaterial ~= Enum.Material.Air then
humanoid.Jump = true
task.wait(0.25)
return true
end
return false
end

local function selectNextStep(hrp, targetPos, lastDir)
local origin = hrp.Position + Vector3.new(0, 2, 0)
local bestScore = math.huge
local bestPos, bestDir = nil, nil

text
local rayParams = RaycastParams.new()
rayParams.FilterDescendantsInstances = {hrp.Parent}
rayParams.FilterType = Enum.RaycastFilterType.Blacklist

for _, dir in ipairs(scanDirs) do
    local ray = Workspace:Raycast(origin, dir * scanRadius, rayParams)
    local pos = ray and ray.Position or origin + dir * scanRadius
    if pos and not checkDangerNearby(pos, safeDistance) and not isPathDangerous(origin, pos, hrp.Parent) then
        local dist = (pos - targetPos).Magnitude
        for _, prevPos in ipairs(lastPositions) do
            if prevPos and (pos - prevPos).Magnitude < stepSize * 0.6 then
                dist = dist + 7
            end
        end
        local score = dist
        if lastDir and lastDir:Dot(dir) > 0.9 then
            score = score * 0.7
        end
        if score < bestScore then
            bestScore = score
            bestPos = pos
            bestDir = dir
        end
    end
end

if bestPos then
    table.insert(lastPositions, bestPos)
    if #lastPositions > 10 then
        table.remove(lastPositions, 1)
    end
end
return bestPos, bestDir
end

local function ultraLidarNavigate(hrp, humanoid, targetPos)
moving = true
local lastDir = nil
local pathPoints = {hrp.Position}
lastPositions = {}

text
while moving and hrp and humanoid and (hrp.Position - targetPos).Magnitude > safeDistance do
    local nextStep, chosenDir = selectNextStep(hrp, targetPos, lastDir)
    if not nextStep then
        warn("[LIDAR] Нет безопасного пути!")
        break
    end

    if tryJump(hrp, humanoid, nextStep) then
        task.wait(parkourMode and 0.1 or 0.25)
    end

    humanoid:MoveTo(nextStep)
    humanoid.MoveToFinished:Wait()

    lastDir = chosenDir
    table.insert(pathPoints, nextStep)
    task.wait(updateInterval)
end
drawPath(pathPoints, Color3.fromRGB(0, 175, 255))
moving = false
end

local function drawScanVisualization(hrp)
local origin = hrp.Position + Vector3.new(0, 2, 0)
for _, dir in ipairs(scanDirs) do
local rayParams = RaycastParams.new()
rayParams.FilterDescendantsInstances = {hrp.Parent}
rayParams.FilterType = Enum.RaycastFilterType.Blacklist
local ray = Workspace:Raycast(origin, dir * scanRadius, rayParams)
local endPos = ray and ray.Position or origin + dir * scanRadius
local part = Instance.new("Part")
part.Anchored = true
part.CanCollide = false
part.Size = Vector3.new(0.07,0.07,(endPos - origin).Magnitude)
part.CFrame = CFrame.new((origin + endPos)/2, endPos)
part.Material = Enum.Material.Neon
part.Color = Color3.fromRGB(0,255,0)
part.Parent = Workspace
Debris:AddItem(part,1)
end
end

local function clearConnections()
for _, conn in ipairs(connections) do
if conn and conn.Connected then
conn:Disconnect()
end
end
connections = {}
end

-- Commands --

Plugin.Commands["lidartap"] = {
ListName = "lidartap",
Description = "Перемещение к точке ПКМ с LIDAR навигацией",
Aliases = {},
Function = function(args, speaker)
if followMode == "lidartap" then
clearConnections()
moving = false
followMode = nil
print("[LIDAR] lidartap выключен")
return
end
updateScanSettings()
followMode = "lidartap"
print("[LIDAR] lidartap включен, кликайте ПКМ для движения")
local conn = UserInputService.InputBegan:Connect(function(input, processed)
if processed then return end
if input.UserInputType == Enum.UserInputType.MouseButton2 then
if moving then return end
local mouse = localPlayer:GetMouse()
local dest = mouse.Hit.p
local char, hrp, humanoid = getCharacter(localPlayer)
if char and hrp and humanoid then
coroutine.wrap(function()
ultraLidarNavigate(hrp, humanoid, dest)
end)()
end
end
end)
table.insert(connections, conn)
end
}

Plugin.Commands["lidarfollow"] = {
ListName = "lidarfollow [player]",
Description = "Следовать за игроком с адаптивным LIDAR",
Aliases = {},
Function = function(args, speaker)
clearConnections()
local Players = game:GetService("Players")
local targetFilter = args and args or "nearest"
local targetPlayers = {}
for _, p in pairs(Players:GetPlayers()) do
if p.Name:lower():find(targetFilter:lower()) then
table.insert(targetPlayers, p)
end
end
if #targetPlayers == 0 then
warn("[LIDAR] Цель не найдена")
return
end
currentTarget = targetPlayers
updateScanSettings()
followMode = "lidarfollow"
print("[LIDAR] Следую за "..currentTarget.Name)
local conn = RunService.Heartbeat:Connect(function()
if moving then return end
if not currentTarget or not currentTarget.Character then return end
local char, hrp, humanoid = getCharacter(localPlayer)
local tgtChar, tgtHRP = getCharacter(currentTarget)
if char and hrp and humanoid and tgtChar and tgtHRP then
coroutine.wrap(function()
ultraLidarNavigate(hrp, humanoid, tgtHRP.Position)
end)()
end
end)
table.insert(connections, conn)
end
}

Plugin.Commands["lidarchase"] = {
ListName = "lidarchase [player]",
Description = "Преследовать игрока с прогнозом движения и паркуром",
Aliases = {},
Function = function(args, speaker)
clearConnections()
local Players = game:GetService("Players")
local targetFilter = args and args or "nearest"
local targetPlayers = {}
for _, p in pairs(Players:GetPlayers()) do
if p.Name:lower():find(targetFilter:lower()) then
table.insert(targetPlayers, p)
end
end
if #targetPlayers == 0 then
warn("[LIDAR] Цель не найдена")
return
end
currentTarget = targetPlayers
parkourMode = true
updateScanSettings()
followMode = "lidarchase"
print("[LIDAR] Преследую "..currentTarget.Name)
local conn = RunService.Heartbeat:Connect(function()
if moving then return end
if not currentTarget or not currentTarget.Character then return end
local char, hrp, humanoid = getCharacter(localPlayer)
local tgtChar, tgtHRP = getCharacter(currentTarget)
if char and hrp and humanoid and tgtChar and tgtHRP then
coroutine.wrap(function()
ultraLidarNavigate(hrp, humanoid, tgtHRP.Position)
end)()
end
end)
table.insert(connections, conn)
end
}

Plugin.Commands["parkourmode"] = {
ListName = "parkourmode",
Description = "Вкл/выкл паркур режим с расширенным LIDAR",
Aliases = {},
Function = function()
parkourMode = not parkourMode
updateScanSettings()
print(parkourMode and "[LIDAR] Паркур режим ВКЛ" or "[LIDAR] Паркур режим ВЫКЛ")
end
}

Plugin.Commands["lidarrandom"] = {
ListName = "lidarrandom",
Description = "Случайное патрулирование с использованием LIDAR",
Aliases = {},
Function = function()
clearConnections()
followMode = "lidarrandom"
print("[LIDAR] Случайное патрулирование включено")
local char, hrp, humanoid = getCharacter(localPlayer)
if not char or not hrp or not humanoid then return end
moving = true
coroutine.wrap(function()
while moving do
local randDir = Vector3.new(math.random()*2-1, math.random()*0.1-0.05, math.random()*2-1).Unit
local randDist = math.random(15, 60)
local tgtPos = hrp.Position + randDir * randDist
ultraLidarNavigate(hrp, humanoid, tgtPos)
task.wait(0.3)
end
end)()
end
}

Plugin.Commands["lidarshow"] = {
ListName = "lidarshow",
Description = "Визуализация 3D LIDAR сканирования",
Aliases = {},
Function = function()
local char, hrp, humanoid = getCharacter(localPlayer)
if not hrp then
print("[LIDAR] HumanoidRootPart не найден")
return
end
drawScanVisualization(hrp)
print("[LIDAR] Визуализация сканирования показана")
end
}

Plugin.Commands["lidarstop"] = {
ListName = "lidarstop",
Description = "Остановить всю навигацию и движение",
Aliases = {"stop"},
Function = function()
clearConnections()
moving = false
parkourMode = false
followMode = nil
currentTarget = nil
local char, hrp, humanoid = getCharacter(localPlayer)
if humanoid then humanoid:Move(Vector3.new()) end
print("[LIDAR] Движение и навигация остановлены")
end
}

return Plugin

